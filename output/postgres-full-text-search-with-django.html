<!doctype html><html lang=ko><meta charset=utf-8><meta content=ie=edge http-equiv=x-ua-compatible><meta name=description><meta content=width=device-width,height=device-height,initial-scale=1 name=viewport><title>lchfkorea</title><meta content=django name=tags><meta content=postgres name=tags><meta content=lchfkorea property=og:site_name><meta content=article property=og:type><meta content="Postgres Full-Text Search With Django" property=og:title><meta content=./postgres-full-text-search-with-django.html property=og:url><meta content="Django has added support for Postgres's built-in full-text searching as of version 1.10. This is a great alternative to a heavier search system such as elasticsearch or SOLR, when we want decent search capabilities without having to setup and maintain another service. Postgres's full-text search is Good Enough for …" property=og:description><meta content=2017-05-03 property=article:published_time><meta content=Web property=article:section><meta content=django property=article:tag><meta content=postgres property=article:tag><meta content="DongBuem Lee" property=article:author><meta content=./images/postgres-full-text-search-with-django/haystack_small.jpg property=og:image><link href=./theme/icons/apple-touch-icon-57x57.png rel=apple-touch-icon sizes=57x57><link href=./theme/icons/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=./theme/icons/apple-touch-icon-72x72.png rel=apple-touch-icon sizes=72x72><link href=./theme/icons/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=./theme/icons/apple-touch-icon-114x114.png rel=apple-touch-icon sizes=114x114><link href=./theme/icons/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=./theme/icons/apple-touch-icon-144x144.png rel=apple-touch-icon sizes=144x144><link href=./theme/icons/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=./theme/icons/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=./theme/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=./theme/icons/android-chrome-192x192.png rel=icon sizes=192x192 type=image/png><link href=./theme/icons/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=./theme/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=./theme/icons/manifest.json rel=manifest><link rel="shortcut icon" href=./theme/icons/favicon.ico><meta content=#00aba9 name=msapplication-TileColor><meta content=theme/icons/mstile-144x144.png name=msapplication-TileImage><meta content=theme/icons/browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><link href=https://fonts.googleapis.com/css?family=Open+Sans:400,700|Oswald:400,700 rel=stylesheet><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css rel=stylesheet><link href=./theme/styles/theme.css rel=stylesheet><body><header id=main-header><ul id=main-menu role=nav><li><a href=./category/graphics.html>Graphics</a><li><a href=./category/misc.html>misc</a><li><a href=./category/mobile.html>Mobile</a><li class=active><a href=./category/web.html>Web</a></ul><section id=masthead><img src=./theme/images/toaster.png><h1><a href=./>lchfkorea</a></h1><p>first trys by MindBuild</section></header><header class="jumbo dark" id=article-header><div id=jumbo-image style=background-image:url(./images/postgres-full-text-search-with-django/haystack_large.jpg)></div><div id=jumbo-attribution>Image courtesy <a href=https://www.pexels.com/photo/field-village-summer-agriculture-33079/ target=_blank> Pexels </a></div><div id=title><h2><a title="Permalink to Postgres Full-Text Search With Django" href=./postgres-full-text-search-with-django.html rel=bookmark> Postgres Full-Text Search With Django </a></h2><footer><time class=published datetime=2017-05-03T00:00:00+09:00>5월 3, 2017</time></footer></div></header><section id=article><div class=markdown id=article-content><p>Django has <a href=https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/>added support</a> for Postgres's <a href=https://www.postgresql.org/docs/9.6/static/textsearch.html>built-in full-text searching</a> as of version 1.10. This is a great alternative to a heavier search system such as <a href=https://www.elastic.co/products/elasticsearch>elasticsearch</a> or <a href=http://lucene.apache.org/solr/>SOLR</a>, when we want decent search capabilities without having to setup and maintain another service. Postgres's full-text search is <a href=http://rachbelaid.com/postgres-full-text-search-is-good-enough/>Good Enough</a> for a lot of use cases.<p>With this quick guide, I'll show how to add full-text searching to a Django application. Simple use-cases are covered pretty well in the <a href=https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/>Django documentation</a>, so I will focus on a slightly more advanced example that allows searching through multiple fields, including data through relationships, weighting fields differently, adding an index for speed, and methods to keep the search data up-to-date.<p>It should go without saying that this is focused on Django with a PostgreSQL database back-end. This will not work with SQLite or MySQL. I also assume familiarity with Django and a basic understanding of Postgres.<p>An example project is available <a href=https://github.com/nshafer/pgfulltext>on github</a> that follows this guide.<h2>Models</h2><p>We will use these models as an example. It's simple data for a Blog-like application consisting of Posts with data both directly included and referenced through relationships. But most importantly, we have data we want to search through that exists as ManyToOne (author) and ManyToMany (tags)relationships.<div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>Author</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>name</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>50</span><span class=p>)</span>


<span class=k>class</span> <span class=nc>Tag</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>name</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>20</span><span class=p>)</span>


<span class=k>class</span> <span class=nc>Post</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>title</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>50</span><span class=p>)</span>
    <span class=n>content</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>TextField</span><span class=p>()</span>
    <span class=n>author</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ForeignKey</span><span class=p>(</span><span class=n>Author</span><span class=p>)</span>
    <span class=n>tags</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ManyToManyField</span><span class=p>(</span><span class=n>Tag</span><span class=p>)</span>
</code></pre></div><p>We will use this sample data:<div class=highlight><pre><span></span><code><span class=n>jim</span> <span class=o>=</span> <span class=n>Author</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Jim Blogwriter"</span><span class=p>)</span>
<span class=n>nancy</span> <span class=o>=</span> <span class=n>Author</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Nancy Blogaday"</span><span class=p>)</span>

<span class=n>databases</span> <span class=o>=</span> <span class=n>Tag</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Databases"</span><span class=p>)</span>
<span class=n>programming</span> <span class=o>=</span> <span class=n>Tag</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Programming"</span><span class=p>)</span>
<span class=n>python</span> <span class=o>=</span> <span class=n>Tag</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Python"</span><span class=p>)</span>
<span class=n>postgres</span> <span class=o>=</span> <span class=n>Tag</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Postgres"</span><span class=p>)</span>
<span class=n>django</span> <span class=o>=</span> <span class=n>Tag</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span><span class=n>name</span><span class=o>=</span><span class=s2>"Django"</span><span class=p>)</span>

<span class=n>django_post</span> <span class=o>=</span> <span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span>
    <span class=n>title</span><span class=o>=</span><span class=s2>"Django, the western character"</span><span class=p>,</span>
    <span class=n>content</span><span class=o>=</span><span class=s2>"Django is a character who appears in a number of spaghetti "</span>
            <span class=s2>"western films."</span><span class=p>,</span>
    <span class=n>author</span><span class=o>=</span><span class=n>jim</span>
<span class=p>)</span>
<span class=n>django_post</span><span class=o>.</span><span class=n>tags</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>django</span><span class=p>)</span>

<span class=n>python_post</span> <span class=o>=</span> <span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span>
    <span class=n>title</span><span class=o>=</span><span class=s2>"Python is a programming language"</span><span class=p>,</span>
    <span class=n>content</span><span class=o>=</span><span class=s2>"Python is a programming language created by Guido van Rossum "</span>
            <span class=s2>"and first released in 1991. Django is written in Python. Python "</span>
            <span class=s2>"can connect to databases."</span><span class=p>,</span>
    <span class=n>author</span><span class=o>=</span><span class=n>nancy</span>
<span class=p>)</span>
<span class=n>python_post</span><span class=o>.</span><span class=n>tags</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>django</span><span class=p>,</span> <span class=n>programming</span><span class=p>,</span> <span class=n>python</span><span class=p>)</span>

<span class=n>postgres_post</span> <span class=o>=</span> <span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>create</span><span class=p>(</span>
    <span class=n>title</span><span class=o>=</span><span class=s2>"What is Postgres"</span><span class=p>,</span>
    <span class=n>content</span><span class=o>=</span><span class=s2>"PostgreSQL, commonly Postgres, is an open-source, "</span>
            <span class=s2>"object-relational database (ORDBMS)."</span><span class=p>,</span>
    <span class=n>author</span><span class=o>=</span><span class=n>nancy</span>
<span class=p>)</span>
<span class=n>postgres_post</span><span class=o>.</span><span class=n>tags</span><span class=o>.</span><span class=n>add</span><span class=p>(</span><span class=n>databases</span><span class=p>,</span> <span class=n>postgres</span><span class=p>)</span>
</code></pre></div><h2>Building Documents</h2><p>The first step is going to be building <em>Documents</em> for our posts. Each Document will be a logical representation of a single post, including:<ul><li>title<li>content<li>Author's name<li>All tag names</ul><p>Here is an example Django query:<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.db.models.functions</span> <span class=kn>import</span> <span class=n>Concat</span>
<span class=kn>from</span> <span class=nn>django.db.models</span> <span class=kn>import</span> <span class=n>TextField</span><span class=p>,</span> <span class=n>Value</span> <span class=k>as</span> <span class=n>V</span>
<span class=kn>from</span> <span class=nn>django.contrib.postgres.aggregates</span> <span class=kn>import</span> <span class=n>StringAgg</span>

<span class=n>document</span><span class=o>=</span><span class=n>Concat</span><span class=p>(</span>
    <span class=s1>'title'</span><span class=p>,</span> <span class=n>V</span><span class=p>(</span><span class=s1>' '</span><span class=p>),</span>
    <span class=s1>'content'</span><span class=p>,</span> <span class=n>V</span><span class=p>(</span><span class=s1>' '</span><span class=p>),</span>
    <span class=s1>'author__name'</span><span class=p>,</span> <span class=n>V</span><span class=p>(</span><span class=s1>' '</span><span class=p>),</span>
    <span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span>
    <span class=n>output_field</span><span class=o>=</span><span class=n>TextField</span><span class=p>()</span>
<span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>document</span><span class=p>)</span><span class=o>.</span><span class=n>values_list</span><span class=p>(</span><span class=s1>'document'</span><span class=p>,</span> <span class=n>flat</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre><span></span><code>&LTQuerySet [
  "Django, the western character Django is a character who appears in a
    number of spaghetti western films. Jim Blogwriter Django",
  "Python is a programming language Python is a programming language
    created by Guido van Rossum and first released in 1991. Django is
    written in Python. Python can connect to databases. Nancy Blogaday
    Python Django Programming",
  "What is Postgres PostgreSQL, commonly Postgres, is an open-source,
    object-relational database (ORDBMS). Nancy Blogaday Postgres Databases"
]>
</code></pre></div><p>This includes all of our data for each post, separated by spaces.<h2>Search Vectors</h2><p>So now that we have our documents, we need to convert them into a format that Postgres can index and search through. Postgres calls these <a href=https://www.postgresql.org/docs/9.6/static/textsearch-controls.html#TEXTSEARCH-PARSING-DOCUMENTS>Vectors</a>. Django has a class to encapsulate this functionality called <a href=https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/#searchvector>SearchVector</a>. A <code>SearchVector</code> can also take a weight, so we'll rewrite our query to create vectors.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVector</span>
<span class=kn>from</span> <span class=nn>django.contrib.postgres.aggregates</span> <span class=kn>import</span> <span class=n>StringAgg</span>

<span class=n>vector</span><span class=o>=</span><span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'author__name'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>)</span><span class=o>.</span><span class=n>values_list</span><span class=p>(</span><span class=s1>'document'</span><span class=p>,</span> <span class=n>flat</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre><span></span><code>&LTQuerySet [
  "'appear':10C 'blogwrit':19B 'charact':4A,8C 'django':1A,5C,20B 'film':17C
    'jim':18B 'number':13C 'spaghetti':15C 'western':3A,16C",
  "'1991':20C 'blogaday':32B 'connect':28C 'creat':11C 'databas':30C
    'django':21C,34B 'first':17C 'guido':13C 'languag':5A,10C 'nanci':31B
    'program':4A,9C,35B 'python':1A,6C,25C,26C,33B 'releas':18C
    'rossum':15C 'van':14C 'written':23C",
  "'blogaday':18B 'common':5C 'databas':15C,20B 'nanci':17B 'object':13C
    'object-rel':12C 'open':10C 'open-sourc':9C 'ordbm':16C
    'postgr':3A,6C,19B 'postgresql':4C 'relat':14C 'sourc':11C"
]>
</code></pre></div><p>Each document has been normalized down to a common set of <em>word stems</em>. This includes dropping case, dropping common prefixes and suffixes (like 's', and 'es'), and removing common words like 'a', 'an' and 'the'. The numbers are where in the document it found that stem, and the letter is the weight. If we want to override the configuration setting for how Postgres processes the words, for example to specify a different language, then we can pass an optional <code>config</code> parameter to SearchVector. If not given, then it will use whatever the database is configured to use by default, most likely based on the configured locale.<h2>Performing a search</h2><p>So now that we have our documents, we can perform a search. The easiest way to do this is to filter on our documents.<div class=highlight><pre><span></span><code><span class=n>vector</span><span class=o>=</span><span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'author__name'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>)</span><span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=s1>'django'</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre><span></span><code>&LTQuerySet [&LTPost: Django, the western character>,
           &LTPost: Python is a programming language>]>
</code></pre></div><p>By default, django will use the <code>plainto_tsquery()</code> <a href=https://www.postgresql.org/docs/9.6/static/textsearch-controls.html#TEXTSEARCH-PARSING-QUERIES>function</a> in Postgres to parse the query. The short of this is that it will search for documents that match all of the words. However, instead of a string we can pass a <a href=https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/#searchquery>SearchQuery()</a> instance, which can be combined with several boolean operators.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchQuery</span>

<span class=n>query</span> <span class=o>=</span> <span class=n>SearchQuery</span><span class=p>(</span><span class=s1>'django'</span><span class=p>)</span> <span class=o>&</span> <span class=n>SearchQuery</span><span class=p>(</span><span class=s1>'program'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>)</span><span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>query</span><span class=p>)</span>
</code></pre></div><p>If we use a custom <code>config</code> with SearchVector(), then we should use that same <code>config</code> with SearchQuery().<h2>Ranking</h2><p>Results are most useful if we can rank them, taking into consideration the different weights we've assigned to each part of the document. Django provides the SearchRank class for this purpose.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVector</span><span class=p>,</span> <span class=n>SearchQuery</span><span class=p>,</span> <span class=n>SearchRank</span>
<span class=kn>from</span> <span class=nn>django.contrib.postgres.aggregates</span> <span class=kn>import</span> <span class=n>StringAgg</span>

<span class=n>vector</span><span class=o>=</span><span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'author__name'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span>
<span class=n>query</span> <span class=o>=</span> <span class=n>SearchQuery</span><span class=p>(</span><span class=s1>'django'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span>\
    <span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>,</span> <span class=n>rank</span><span class=o>=</span><span class=n>SearchRank</span><span class=p>(</span><span class=n>vector</span><span class=p>,</span> <span class=n>query</span><span class=p>))</span>\
    <span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>query</span><span class=p>)</span>\
    <span class=o>.</span><span class=n>order_by</span><span class=p>(</span><span class=s1>'-rank'</span><span class=p>)</span>\
    <span class=o>.</span><span class=n>values_list</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=s1>'rank'</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre><span></span><code>&LTQuerySet [
  ('Django, the western character', 0.665342),
  ('Python is a programming language', 0.364756)
]>
</code></pre></div><p>This gives us the functionality we want, but this isn't the best way to go about it if we care about performance. Every time we run this query the database has to build all the documents, for all rows in the table before it can search and rank them. It's fine for a few rows, but after more than a couple hundred it's going to start slowing down to unacceptable speeds. If our documents only contained data from a single table, we could just <a href=https://www.postgresql.org/docs/current/static/textsearch-tables.html#TEXTSEARCH-TABLES-INDEX>build a GIN index</a>, but that won't work in this case since we pull extra data from other tables. So what we really want to do is to pre-calculate all of the documents and store them in the database.<h1>Storing Vectors with SearchVectorField</h1><p>Django provides a special field that allows us to store pre-calculated vectors in a field called <code>SearchVectorField</code>. We'll add that field to our Post model:<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVectorField</span>

<span class=k>class</span> <span class=nc>Post</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=o>...</span>
    <span class=n>search_vector</span> <span class=o>=</span> <span class=n>SearchVectorField</span><span class=p>(</span><span class=n>null</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</code></pre></div><p>Then we'll migrate this to add the field.<div class=highlight><pre><span></span><code>./manage.py<span class=w> </span>makemigrations
./manage.py<span class=w> </span>migrate
</code></pre></div><p>Let's update this field manually for now.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVector</span><span class=p>,</span> <span class=n>SearchQuery</span><span class=p>,</span> <span class=n>SearchRank</span>
<span class=kn>from</span> <span class=nn>django.contrib.postgres.aggregates</span> <span class=kn>import</span> <span class=n>StringAgg</span>

<span class=n>vector</span><span class=o>=</span><span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'author__name'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span>
<span class=k>for</span> <span class=n>post</span> <span class=ow>in</span> <span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>):</span>
    <span class=n>post</span><span class=o>.</span><span class=n>search_vector</span> <span class=o>=</span> <span class=n>post</span><span class=o>.</span><span class=n>document</span>
    <span class=n>post</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=n>update_fields</span><span class=o>=</span><span class=p>[</span><span class=s1>'search_vector'</span><span class=p>])</span>
</code></pre></div><p><strong>Note:</strong> This will issue an UPDATE for each row in the table, which will take forever if our table has a lot of rows. If we are only including fields from a single model in our document, then something like this would be much more efficient:<div class=highlight><pre><span></span><code><span class=n>vector</span><span class=o>=</span><span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
       <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>update</span><span class=p>(</span><span class=n>search_vector</span><span class=o>=</span><span class=n>vector</span><span class=p>)</span>
</code></pre></div><p>Django doesn't allow us to use aggregate functions with an update clause, but Postgres does, so if we really wanted, we could issue a query like this to refresh all of the documents at once:<div class=highlight><pre><span></span><code><span class=k>UPDATE</span><span class=w> </span><span class=n>blog_post</span>
<span class=k>SET</span><span class=w> </span><span class=n>search_vector</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>document</span><span class=p>.</span><span class=n>vector</span>
<span class=k>FROM</span><span class=w> </span><span class=p>(</span>
<span class=w>     </span><span class=k>SELECT</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span><span class=p>,</span>
<span class=w>            </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=n>post</span><span class=p>.</span><span class=n>title</span><span class=p>),</span><span class=w> </span><span class=s1>'A'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>            </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=n>post</span><span class=p>.</span><span class=n>content</span><span class=p>),</span><span class=w> </span><span class=s1>'C'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>            </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=n>author</span><span class=p>.</span><span class=n>name</span><span class=p>),</span><span class=w> </span><span class=s1>'B'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>            </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=k>COALESCE</span><span class=p>(</span><span class=n>string_agg</span><span class=p>(</span><span class=n>tag</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s1>', '</span><span class=p>),</span><span class=w> </span><span class=s1>''</span><span class=p>)),</span><span class=w> </span><span class=s1>'B'</span><span class=p>)</span>
<span class=w>              </span><span class=k>AS</span><span class=w> </span><span class=n>vector</span>
<span class=w>     </span><span class=k>FROM</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>post</span>
<span class=w>     </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_author</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>author</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>author</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>author_id</span>
<span class=w>     </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_post_tags</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>post_tags</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>post_tags</span><span class=p>.</span><span class=n>post_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span>
<span class=w>     </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_tag</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>tag</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>tag</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post_tags</span><span class=p>.</span><span class=n>tag_id</span>
<span class=w>     </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>author</span><span class=p>.</span><span class=n>id</span>
<span class=w>   </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>document</span>
<span class=k>WHERE</span><span class=w> </span><span class=n>blog_post</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>document</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
</code></pre></div><h2>Searching on search_vector</h2><p>Now that we have our documents stored, we can easily search on them<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.db.models</span> <span class=kn>import</span> <span class=n>F</span>
<span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVector</span><span class=p>,</span> <span class=n>SearchQuery</span><span class=p>,</span> <span class=n>SearchRank</span>

<span class=n>query</span> <span class=o>=</span> <span class=n>SearchQuery</span><span class=p>(</span><span class=s1>'django'</span><span class=p>)</span>
<span class=n>Post</span><span class=o>.</span><span class=n>objects</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>rank</span><span class=o>=</span><span class=n>SearchRank</span><span class=p>(</span><span class=n>F</span><span class=p>(</span><span class=s1>'search_vector'</span><span class=p>),</span> <span class=n>query</span><span class=p>))</span>\
    <span class=o>.</span><span class=n>filter</span><span class=p>(</span><span class=n>search_vector</span><span class=o>=</span><span class=n>query</span><span class=p>)</span><span class=o>.</span><span class=n>order_by</span><span class=p>(</span><span class=s1>'-rank'</span><span class=p>)</span><span class=o>.</span><span class=n>values_list</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=s1>'rank'</span><span class=p>)</span>
</code></pre></div><div class=highlight><pre><span></span><code>&LTQuerySet [
  ('Django, the western character', 0.665342),
  ('Python is a programming language', 0.364756)
]>
</code></pre></div><h2>Indexing</h2><p>Now that the documents are stored in a field, we can create a GIN index to speed up searching. With Django 1.11, this is as easy as adding an <code>indexes</code> Meta option to our model, then create and apply a migration.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.indexes</span> <span class=kn>import</span> <span class=n>GinIndex</span>

<span class=k>class</span> <span class=nc>Post</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>title</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>50</span><span class=p>)</span>
    <span class=n>content</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>TextField</span><span class=p>()</span>
    <span class=n>author</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ForeignKey</span><span class=p>(</span><span class=n>Author</span><span class=p>)</span>
    <span class=n>tags</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ManyToManyField</span><span class=p>(</span><span class=n>Tag</span><span class=p>)</span>
    <span class=n>search_vector</span> <span class=o>=</span> <span class=n>SearchVectorField</span><span class=p>(</span><span class=n>null</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=k>class</span> <span class=nc>Meta</span><span class=p>:</span>
        <span class=n>indexes</span> <span class=o>=</span> <span class=p>[</span>
            <span class=n>GinIndex</span><span class=p>(</span><span class=n>fields</span><span class=o>=</span><span class=p>[</span><span class=s1>'search_vector'</span><span class=p>])</span>
        <span class=p>]</span>
</code></pre></div><p>For Django 1.10, we'd need to create an empty migration then add a <code>RunSQL</code> operation:<div class=highlight><pre><span></span><code><span class=n>migrations</span><span class=o>.</span><span class=n>RunSQL</span><span class=p>(</span>
    <span class=s2>"CREATE INDEX blog_post_search_vector_idx ON blog_post USING gin(search_vector)"</span><span class=p>,</span>
    <span class=s2>"DROP INDEX blog_post_search_vector_idx"</span>
<span class=p>)</span>
</code></pre></div><h1>Updating the documents</h1><p>This is great and all, but as soon as any of the data changes, the documents will be out of date, and the search results will be incorrect. The first way we could address this is with a cron or scheduled task that updates the whole table (like we did above) at regular intervals. This would be a good option for an application that processes a lot of updates, or does its updates in large batches. This way we don't add overhead to every update, and instead can more efficiently update all rows at once.<p>For other applications that have a slow steady stream of updates, it would be more appropriate to update every time the data changed. The upside is that the search data will always be up to date. The downside is that every update will incur extra overhead as the search_vector is calculated.<p>A compromise would be to queue up the update to the search_vector as an asynchronous process, so that it's updated fairly quickly, but the updates can still be done as a batch. This is outside the scope of this article, but it shouldn't be too difficult depending on the application architecture.<p>The best method is going to depend on the particular application. Here are a couple simple ways to update on every save.<h2>Overriding save()</h2><p>One method to update the document is to override the save() method on Post. With this method, every time the data that search relies on is updated, then the search_vector is also updated alongside it. So search results reflect data changes immediately. This does incur an overhead on every update to the database, though.<p>First we'll create a custom manager that adds documents to the queryset when we request it, so we can keep things DRY, and only have our SearchVectors defined in one place.<div class=highlight><pre><span></span><code><span class=k>class</span> <span class=nc>PostManager</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Manager</span><span class=p>):</span>
    <span class=k>def</span> <span class=nf>with_documents</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
        <span class=n>vector</span> <span class=o>=</span> <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'title'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'A'</span><span class=p>)</span> <span class=o>+</span> \
                 <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'content'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'C'</span><span class=p>)</span> <span class=o>+</span> \
                 <span class=n>SearchVector</span><span class=p>(</span><span class=s1>'author__name'</span><span class=p>,</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span> <span class=o>+</span> \
                 <span class=n>SearchVector</span><span class=p>(</span><span class=n>StringAgg</span><span class=p>(</span><span class=s1>'tags__name'</span><span class=p>,</span> <span class=n>delimiter</span><span class=o>=</span><span class=s1>' '</span><span class=p>),</span> <span class=n>weight</span><span class=o>=</span><span class=s1>'B'</span><span class=p>)</span>
        <span class=k>return</span> <span class=bp>self</span><span class=o>.</span><span class=n>get_queryset</span><span class=p>()</span><span class=o>.</span><span class=n>annotate</span><span class=p>(</span><span class=n>document</span><span class=o>=</span><span class=n>vector</span><span class=p>)</span>
</code></pre></div><p>Now we'll update our Post model and add our custom manager and a custom save function. The idea here is to save the data to the database, then do a SELECT query that joins all the data together and then save the new search_vector. So each save will result in an UPDATE, SELECT, then another UPDATE.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.contrib.postgres.search</span> <span class=kn>import</span> <span class=n>SearchVectorField</span><span class=p>,</span> <span class=n>SearchVector</span>

<span class=k>class</span> <span class=nc>Post</span><span class=p>(</span><span class=n>models</span><span class=o>.</span><span class=n>Model</span><span class=p>):</span>
    <span class=n>title</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>CharField</span><span class=p>(</span><span class=n>max_length</span><span class=o>=</span><span class=mi>50</span><span class=p>)</span>
    <span class=n>content</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>TextField</span><span class=p>()</span>
    <span class=n>author</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ForeignKey</span><span class=p>(</span><span class=n>Author</span><span class=p>)</span>
    <span class=n>tags</span> <span class=o>=</span> <span class=n>models</span><span class=o>.</span><span class=n>ManyToManyField</span><span class=p>(</span><span class=n>Tag</span><span class=p>)</span>
    <span class=n>search_vector</span> <span class=o>=</span> <span class=n>SearchVectorField</span><span class=p>(</span><span class=n>null</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>

    <span class=n>objects</span> <span class=o>=</span> <span class=n>PostManager</span><span class=p>()</span>

    <span class=k>def</span> <span class=nf>save</span><span class=p>(</span><span class=bp>self</span><span class=p>,</span> <span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
        <span class=nb>super</span><span class=p>()</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=o>*</span><span class=n>args</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>)</span>
        <span class=k>if</span> <span class=s1>'update_fields'</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>kwargs</span> <span class=ow>or</span> <span class=s1>'search_vector'</span> <span class=ow>not</span> <span class=ow>in</span> <span class=n>kwargs</span><span class=p>[</span><span class=s1>'update_fields'</span><span class=p>]:</span>
            <span class=n>instance</span> <span class=o>=</span> <span class=bp>self</span><span class=o>.</span><span class=n>_meta</span><span class=o>.</span><span class=n>default_manager</span><span class=o>.</span><span class=n>with_documents</span><span class=p>()</span><span class=o>.</span><span class=n>get</span><span class=p>(</span><span class=n>pk</span><span class=o>=</span><span class=bp>self</span><span class=o>.</span><span class=n>pk</span><span class=p>)</span>
            <span class=n>instance</span><span class=o>.</span><span class=n>search_vector</span> <span class=o>=</span> <span class=n>instance</span><span class=o>.</span><span class=n>document</span>
            <span class=n>instance</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=n>update_fields</span><span class=o>=</span><span class=p>[</span><span class=s1>'search_vector'</span><span class=p>])</span>
</code></pre></div><p>Also, updates to authors and tags won't trigger the <code>save()</code>, so we'll also add signals for those that force a <code>save()</code> on the Post as well to update the search_vector.<div class=highlight><pre><span></span><code><span class=kn>from</span> <span class=nn>django.db.models.signals</span> <span class=kn>import</span> <span class=n>post_save</span><span class=p>,</span> <span class=n>m2m_changed</span>
<span class=kn>from</span> <span class=nn>django.dispatch</span> <span class=kn>import</span> <span class=n>receiver</span>

<span class=nd>@receiver</span><span class=p>(</span><span class=n>post_save</span><span class=p>,</span> <span class=n>sender</span><span class=o>=</span><span class=n>Author</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>author_changed</span><span class=p>(</span><span class=n>sender</span><span class=p>,</span> <span class=n>instance</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
    <span class=k>for</span> <span class=n>post</span> <span class=ow>in</span> <span class=n>instance</span><span class=o>.</span><span class=n>post_set</span><span class=o>.</span><span class=n>with_documents</span><span class=p>():</span>
        <span class=n>post</span><span class=o>.</span><span class=n>search_vector</span> <span class=o>=</span> <span class=n>post</span><span class=o>.</span><span class=n>document</span>
        <span class=n>post</span><span class=o>.</span><span class=n>save</span><span class=p>(</span><span class=n>update_fields</span><span class=o>=</span><span class=p>[</span><span class=s1>'search_vector'</span><span class=p>])</span>


<span class=nd>@receiver</span><span class=p>(</span><span class=n>m2m_changed</span><span class=p>,</span> <span class=n>sender</span><span class=o>=</span><span class=n>Post</span><span class=o>.</span><span class=n>tags</span><span class=o>.</span><span class=n>through</span><span class=p>)</span>
<span class=k>def</span> <span class=nf>post_tags_changed</span><span class=p>(</span><span class=n>sender</span><span class=p>,</span> <span class=n>instance</span><span class=p>,</span> <span class=n>action</span><span class=p>,</span> <span class=o>**</span><span class=n>kwargs</span><span class=p>):</span>
    <span class=k>if</span> <span class=n>action</span> <span class=ow>in</span> <span class=p>(</span><span class=s1>'post_add'</span><span class=p>,</span> <span class=s1>'post_remove'</span><span class=p>,</span> <span class=s1>'post_clear'</span><span class=p>):</span>
        <span class=n>instance</span><span class=o>.</span><span class=n>save</span><span class=p>()</span>
</code></pre></div><p>Now any changes to a Post, Author or if tags are added, removed or cleared will cause the search data to be updated. If a tag is renamed, then we won't pick up on that without creating another signal handler.<h2>Using triggers</h2><p>It's also possible to install a few triggers in the database that will automatically update the search_vector whenever the data is changed. I won't go into too much detail, but they will look something like this. We can easily add these to a migration that uses a RunSQL operation to install them into our database. The idea is exactly the same as above, but since the database can do it all locally and not have to send data back and forth to Django, it will perform better.<div class=highlight><pre><span></span><code><span class=c1>-- Trigger on insert or update of blog.Post</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>post_search_vector_trigger</span><span class=p>()</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=k>trigger</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span>
<span class=k>BEGIN</span>
<span class=w>  </span><span class=k>SELECT</span><span class=w> </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=k>NEW</span><span class=p>.</span><span class=n>title</span><span class=p>),</span><span class=w> </span><span class=s1>'A'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>         </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=k>NEW</span><span class=p>.</span><span class=n>content</span><span class=p>),</span><span class=w> </span><span class=s1>'C'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>         </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=n>author</span><span class=p>.</span><span class=n>name</span><span class=p>),</span><span class=w> </span><span class=s1>'B'</span><span class=p>)</span><span class=w> </span><span class=o>||</span>
<span class=w>         </span><span class=n>setweight</span><span class=p>(</span><span class=n>to_tsvector</span><span class=p>(</span><span class=k>COALESCE</span><span class=p>(</span><span class=n>string_agg</span><span class=p>(</span><span class=n>tag</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s1>', '</span><span class=p>),</span><span class=w> </span><span class=s1>''</span><span class=p>)),</span><span class=w> </span><span class=s1>'B'</span><span class=p>)</span>
<span class=w>  </span><span class=k>INTO</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>search_vector</span>
<span class=w>  </span><span class=k>FROM</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>post</span>
<span class=w>  </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_author</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>author</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>author</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>author_id</span>
<span class=w>    </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_post_tags</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>post_tags</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>post_tags</span><span class=p>.</span><span class=n>post_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span>
<span class=w>    </span><span class=k>LEFT</span><span class=w> </span><span class=k>JOIN</span><span class=w> </span><span class=n>blog_tag</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>tag</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>tag</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>post_tags</span><span class=p>.</span><span class=n>tag_id</span>
<span class=w>  </span><span class=k>WHERE</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>id</span>
<span class=w>  </span><span class=k>GROUP</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>post</span><span class=p>.</span><span class=n>id</span><span class=p>,</span><span class=w> </span><span class=n>author</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
<span class=w>  </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span>
<span class=k>END</span><span class=p>;</span>
<span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>search_vector_update</span><span class=w> </span><span class=k>BEFORE</span><span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>blog_post</span>
<span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>post_search_vector_trigger</span><span class=p>();</span>

<span class=c1>-- Trigger after blog.Author is updated</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>author_search_vector_trigger</span><span class=p>()</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=k>trigger</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span>
<span class=k>BEGIN</span>
<span class=w>  </span><span class=k>UPDATE</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>author_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>id</span><span class=p>;</span>
<span class=w>  </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span>
<span class=k>END</span><span class=p>;</span>
<span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>search_vector_update</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>blog_author</span>
<span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>author_search_vector_trigger</span><span class=p>();</span>

<span class=c1>-- Trigger after blog.Post.tags are added, deleted from a post</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>tags_search_vector_trigger</span><span class=p>()</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=k>trigger</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span>
<span class=k>BEGIN</span>
<span class=w>  </span><span class=k>IF</span><span class=w> </span><span class=p>(</span><span class=n>TG_OP</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>'DELETE'</span><span class=p>)</span><span class=w> </span><span class=k>THEN</span>
<span class=w>    </span><span class=k>UPDATE</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>OLD</span><span class=p>.</span><span class=n>post_id</span><span class=p>;</span>
<span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=k>OLD</span><span class=p>;</span>
<span class=w>  </span><span class=k>ELSE</span>
<span class=w>    </span><span class=k>UPDATE</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>post_id</span><span class=p>;</span>
<span class=w>    </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span>
<span class=w>  </span><span class=k>END</span><span class=w> </span><span class=k>IF</span><span class=p>;</span>
<span class=k>END</span><span class=p>;</span>
<span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>search_vector_update</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=k>INSERT</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>DELETE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>blog_post_tags</span>
<span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>tags_search_vector_trigger</span><span class=p>();</span>

<span class=c1>-- Trigger after blog.Tag is updated</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>OR</span><span class=w> </span><span class=k>REPLACE</span><span class=w> </span><span class=k>FUNCTION</span><span class=w> </span><span class=n>tag_search_vector_trigger</span><span class=p>()</span><span class=w> </span><span class=k>RETURNS</span><span class=w> </span><span class=k>trigger</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=err>$$</span>
<span class=k>BEGIN</span>
<span class=w>  </span><span class=k>UPDATE</span><span class=w> </span><span class=n>blog_post</span><span class=w> </span><span class=k>SET</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>id</span><span class=w> </span><span class=k>IN</span><span class=w> </span><span class=p>(</span>
<span class=w>    </span><span class=k>SELECT</span><span class=w> </span><span class=n>post_id</span><span class=w> </span><span class=k>FROM</span><span class=w> </span><span class=n>blog_post_tags</span><span class=w> </span><span class=k>WHERE</span><span class=w> </span><span class=n>tag_id</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>NEW</span><span class=p>.</span><span class=n>id</span>
<span class=w>  </span><span class=p>);</span>
<span class=w>  </span><span class=k>RETURN</span><span class=w> </span><span class=k>NEW</span><span class=p>;</span>
<span class=k>END</span><span class=p>;</span>
<span class=err>$$</span><span class=w> </span><span class=k>LANGUAGE</span><span class=w> </span><span class=n>plpgsql</span><span class=p>;</span>
<span class=k>CREATE</span><span class=w> </span><span class=k>TRIGGER</span><span class=w> </span><span class=n>search_vector_update</span><span class=w> </span><span class=k>AFTER</span><span class=w> </span><span class=k>UPDATE</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>blog_tag</span>
<span class=w>  </span><span class=k>FOR</span><span class=w> </span><span class=k>EACH</span><span class=w> </span><span class=k>ROW</span><span class=w> </span><span class=k>EXECUTE</span><span class=w> </span><span class=k>PROCEDURE</span><span class=w> </span><span class=n>tag_search_vector_trigger</span><span class=p>();</span>
</code></pre></div><h1>Conclusion</h1><p>Now we have a working application using Postgres full-text search, and once set up, it can be mostly forgotten about. Compared to setting up <a href=https://www.elastic.co/products/elasticsearch>elasticsearch</a> or <a href=http://lucene.apache.org/solr/>SOLR</a> (even with <a href=http://haystacksearch.org/>Haystack</a>), this is a breeze, and results are going to be good enough for most applications.<p>For more information and more features, such as language support, custom stemming, trigrams, accents, etc, please see the following sources:<ul><li><a href=https://www.postgresql.org/docs/9.6/static/textsearch.html>Official PostgreSQL Full-Text Search Documentation</a><li><a href=https://docs.djangoproject.com/en/1.11/ref/contrib/postgres/search/>Official Django Postgres Search Documentation</a><li><a href=http://rachbelaid.com/postgres-full-text-search-is-good-enough/>Postgres full-text search is Good Enough</a>: Great article on the basics of Postgres full-text search.<li><a href=https://github.com/nshafer/pgfulltext>An example project</a> that this blog post goes along with.</ul><h1>Updates to this article</h1><h2>10/10/17</h2><ul><li>Fixed SQL queries that were doing INNER joins on Tags, which would cause the queries to return nothing if no tags were applied. Switch to LEFT OUTER JOINs.<li>Added another sample Trigger to update search_vectors when tag names are changed.</ul></div><section id=share-buttons><h3>Share this:</h3><ul><li><a class="btn btn-facebook" href="https://www.facebook.com/sharer/sharer.php?u=./postgres-full-text-search-with-django.html&t=Postgres Full-Text Search With Django" title="Share on Facebook" target=_blank> <i class="fa fa-facebook"></i> Facebook </a><li><a class="btn btn-twitter" href="https://twitter.com/intent/tweet?source=./postgres-full-text-search-with-django.html&text=Postgres Full-Text Search With Django" target=_blank title=Tweet> <i class="fa fa-twitter"></i> Twitter </a><li><a class="btn btn-reddit" href="http://www.reddit.com/submit?url=./postgres-full-text-search-with-django.html&title=Postgres Full-Text Search With Django" title="Submit to Reddit" target=_blank> <i class="fa fa-reddit"></i> Reddit </a><li><a class="btn btn-email" href="mailto:?subject=Postgres Full-Text Search With Django&body=Article+from+lchfkorea%0D%0A%0D%0A./postgres-full-text-search-with-django.html%0D%0A%0D%0ADjango has added support for Postgres's built-in full-text searching as of version 1.10. This is a great alternative to a heavier search system such as elasticsearch or SOLR, when we want decent search capabilities without having to setup and maintain another service. Postgres's full-text search is Good Enough for …" target=_blank title=Email> <i class="fa fa-envelope"></i> Email </a></ul></section></section><footer id=main-footer><section id=links><section><h3>Pages</h3><ul><li><a href=./>Home</a><li><a href=./archives.html>Archives</a><li><a href=./pages/colophon.html>Colophon</a></ul></section><section><h3>Categories</h3><ul><li><a href=./category/graphics.html>Graphics</a><li><a href=./category/misc.html>misc</a><li><a href=./category/mobile.html>Mobile</a><li><a href=./category/web.html>Web</a></ul></section><section><h3>Tags</h3><ul class=tag-cloud><li class=tag-1><a href=./tag/android.html>android</a><li class=tag-1><a href=./tag/css.html>css</a><li class="tag-1 tag-2"><a href=./tag/django.html>django</a><li class=tag-1><a href=./tag/docker.html>docker</a><li class="tag-1 tag-2"><a href=./tag/elixir.html>elixir</a><li class="tag-1 tag-2 tag-3"><a href=./tag/gideros.html>gideros</a><li class=tag-1><a href=./tag/gulp.html>gulp</a><li class=tag-1><a href=./tag/ios.html>ios</a><li class="tag-1 tag-2 tag-3 tag-4"><a href=./tag/lua.html>lua</a><li class="tag-1 tag-2"><a href=./tag/math.html>math</a><li class=tag-1><a href=./tag/pelican.html>pelican</a><li class="tag-1 tag-2"><a href=./tag/phoenix.html>phoenix</a><li class=tag-1><a href=./tag/plug.html>plug</a><li class="tag-1 tag-2"><a href=./tag/postgres.html>postgres</a><li class=tag-1><a href=./tag/pycharm.html>pycharm</a><li class=tag-1><a href=./tag/responsive.html>responsive</a><li class=tag-1><a href=./tag/sass.html>sass</a><li class=tag-1><a href=./tag/sublime-text.html>sublime-text</a><li class=tag-1><a href=./tag/web-design.html>web design</a></ul></section><address><h3>Nathan Shafer</h3> <ul><li><a href=https://www.github.com/nshafer>Github</a><li><a href=http://www.normal-tech.com>Normal Technologies LLC</a><li><a href=http://www.typeingames.com>Type-in Games</a></ul></address></section><section id=subfooter><section id=copyright><p>© 2025 Nathan Shafer<p id=license>All work is licensed under a <a href=http://creativecommons.org/licenses/by/4.0/ rel=license>Creative Commons Attribution 4.0 International License</a> unless otherwise specified.</section><a title="Subscribe to my feed" href=http://feeds.feedburner.com/Lotechnica id=subscribe-link rel=alternate type=application/rss+xml> <img alt src=//feedburner.google.com/fb/images/pub/feed-icon32x32.png style=border:0> </a></section></footer>