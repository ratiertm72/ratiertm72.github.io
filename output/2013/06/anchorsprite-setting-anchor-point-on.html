<!doctype html><html lang=ko><meta charset=utf-8><meta content=ie=edge http-equiv=x-ua-compatible><meta name=description><meta content=width=device-width,height=device-height,initial-scale=1 name=viewport><title>lchfkorea</title><meta content=lua name=tags><meta content=gideros name=tags><meta content=lchfkorea property=og:site_name><meta content=article property=og:type><meta content="AnchorSprite: Setting an anchor point on any Sprite" property=og:title><meta content=../../2013/06/anchorsprite-setting-anchor-point-on.html property=og:url><meta content="A class to allow you to set arbitrary anchor points on any sprite with little overhead." property=og:description><meta content=2013-06-12 property=article:published_time><meta content=Graphics property=article:section><meta content=lua property=article:tag><meta content=gideros property=article:tag><meta content="DongBuem Lee" property=article:author><link href=../../theme/icons/apple-touch-icon-57x57.png rel=apple-touch-icon sizes=57x57><link href=../../theme/icons/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=../../theme/icons/apple-touch-icon-72x72.png rel=apple-touch-icon sizes=72x72><link href=../../theme/icons/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=../../theme/icons/apple-touch-icon-114x114.png rel=apple-touch-icon sizes=114x114><link href=../../theme/icons/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=../../theme/icons/apple-touch-icon-144x144.png rel=apple-touch-icon sizes=144x144><link href=../../theme/icons/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=../../theme/icons/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=../../theme/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=../../theme/icons/android-chrome-192x192.png rel=icon sizes=192x192 type=image/png><link href=../../theme/icons/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=../../theme/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=../../theme/icons/manifest.json rel=manifest><link rel="shortcut icon" href=../../theme/icons/favicon.ico><meta content=#00aba9 name=msapplication-TileColor><meta content=theme/icons/mstile-144x144.png name=msapplication-TileImage><meta content=theme/icons/browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><link href=https://fonts.googleapis.com/css?family=Open+Sans:400,700|Oswald:400,700 rel=stylesheet><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css rel=stylesheet><link href=../../theme/styles/theme.css rel=stylesheet><body><header id=main-header><ul id=main-menu role=nav><li class=active><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul><section id=masthead><img src=../../theme/images/toaster.png><h1><a href=../../>lchfkorea</a></h1><p>first trys by MindBuild</section></header><header id=article-header><div id=title><h2><a title="Permalink to AnchorSprite: Setting an anchor point on any Sprite" href=../../2013/06/anchorsprite-setting-anchor-point-on.html rel=bookmark> AnchorSprite: Setting an anchor point on any Sprite </a></h2><footer><time class=published datetime=2013-06-12T00:00:00+09:00>6월 12, 2013</time></footer></div></header><section id=article><div class=markdown id=article-content><p>Having done a lot of work with matrices in <a href=http://giderosmobile.com/>Gideros</a> recently, during a <a href=http://www.giderosmobile.com/forum/discussion/comment/23535#Comment_23535>discussion at the Gideros forums</a> it occurred to me that with the Matrix class that I <a href=../../2013/05/the-beauty-of-using-matrices-to-apply.html>recently covered</a>, I could possibly address an oft-requested feature of Gideros. The problem is that in Gideros, all Sprite objects have an anchor point of [0,0] that you can't change. So all transformations such as rotation and scaling are relative to the top left point of the Sprite. The one exception to this is with Bitmap objects, where there is a <code>setAnchorPoint()</code> method. But this doesn't help for other Sprite based objects, such as TextFields or Shapes.<p>So I whipped together a class called <a href=https://github.com/nshafer/AnchorSprite/blob/master/AnchorSprite.lua>AnchorSprite</a>, which when added to your project, adds a <code>setAnchorPoint()</code> and <code>getAnchorPoint()</code> method to every Sprite object and all objects that inherit from Sprite. Further, <a href=http://www.giderosmobile.com/forum/profile/315/bowerandy>bowerandy</a> had the <a href=http://www.giderosmobile.com/forum/discussion/comment/23615#Comment_23615>great idea</a> to make this support completely inactive until you set an anchor, that way you could avoid any overhead on sprites that still had the default anchor point.<p>So I'm going to explain a little bit about how this class works. I'm going to skip over most of the matrix stuff since I <a href=../../2013/05/the-beauty-of-using-matrices-to-apply.html>already covered that in detail</a>.<h3>Intercepting Sprite transform methods</h3><p>The first step is to intercept all calls to transform methods of the <code>Sprite</code> class. This includes <code>setPosition()</code>, <code>setScale()</code>, <code>setRotation()</code> as well as all the other specific ones, <code>setX()</code>, <code>setScaleY()</code>, etc. We also need to intercept <code>set()</code> itself. We have to do this, because we don't want the Sprite class to actually change anything. Instead, we just take the desired changes and save them in private member variables. For example, here is how we intercept <code>set()</code>.<div class=highlight><pre><span></span><code><span class=c1>-- Intercept Sprite's set and get functions for position, scale and rotation</span>
<span class=kr>function</span> <span class=nc>AnchorSprite</span><span class=p>:</span><span class=nf>set</span><span class=p>(</span><span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
    <span class=kr>if</span> <span class=n>value</span> <span class=kr>then</span>
        <span class=kr>if</span> <span class=n>key</span> <span class=o>==</span> <span class=s2>"x"</span> <span class=kr>then</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_positionX</span> <span class=o>=</span> <span class=n>value</span>
        <span class=kr>elseif</span> <span class=n>key</span> <span class=o>==</span> <span class=s2>"y"</span> <span class=kr>then</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_positionY</span> <span class=o>=</span> <span class=n>value</span>
        <span class=kr>elseif</span> <span class=n>key</span> <span class=o>==</span> <span class=s2>"scaleX"</span> <span class=kr>then</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_scaleX</span> <span class=o>=</span> <span class=n>value</span>
        <span class=kr>elseif</span> <span class=n>key</span> <span class=o>==</span> <span class=s2>"scaleY"</span> <span class=kr>then</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_scaleY</span> <span class=o>=</span> <span class=n>value</span>
        <span class=kr>elseif</span> <span class=n>key</span> <span class=o>==</span> <span class=s2>"rotation"</span> <span class=kr>then</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_rotation</span> <span class=o>=</span> <span class=n>value</span>
        <span class=kr>else</span>
           <span class=n>self</span><span class=p>.</span><span class=n>_anchorBackup</span><span class=p>.</span><span class=n>set</span><span class=p>(</span><span class=n>self</span><span class=p>,</span> <span class=n>key</span><span class=p>,</span> <span class=n>value</span><span class=p>)</span>
        <span class=kr>end</span>
        <span class=n>self</span><span class=p>:</span><span class=n>_applyTransforms</span><span class=p>()</span>
    <span class=kr>end</span>
<span class=kr>end</span>
</code></pre></div><p>You'll notice that this is in the <code>AnchorSprite</code> class and not the <code>Sprite</code> class just yet. We don't want to intercept it until an anchor point is set, which I'll show in a bit.<p>So just to show another example, this is what our intercepted <code>setPosition()</code> method will look like.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>AnchorSprite</span><span class=p>:</span><span class=nf>setPosition</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>set</span><span class=p>(</span><span class=s2>"x"</span><span class=p>,</span> <span class=n>x</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>set</span><span class=p>(</span><span class=s2>"y"</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><h3>Applying the transforms</h3><p>The thing to notice is that we're not doing anything with the values being passed in, just storing them in private member variables. This is because we need to basically keep a stack of transforms in memory, so that we can apply them all whenever any of them change. This is done in the <code>_applyTransforms</code>method, which is called every time <code>set()</code> is called.<div class=highlight><pre><span></span><code><span class=c1>-- New function to apply all transforms whenever anything changes</span>
<span class=kr>function</span> <span class=nc>AnchorSprite</span><span class=p>:</span><span class=nf>_applyTransforms</span><span class=p>()</span>
</code></pre></div><p>This function will do all the calculations needed to apply the transforms. It starts from scratch with a brand new Matrix.<div class=highlight><pre><span></span><code>    <span class=c1>-- Create a new identity matrix</span>
    <span class=kd>local</span> <span class=n>matrix</span> <span class=o>=</span> <span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>()</span>
</code></pre></div><p>We then apply that new matrix to the sprite, thus resetting it back to completely default location, rotation and scale. This is so we can get an accurate width and height, so we know how to apply the anchor, which is specified as a percentage of the dimensions of the Sprite. We could forgo this and just have the anchor set as a specific pixel location, but I chose to do it this way to mirror the way that the <code>Bitmap:setAnchorPoint()</code> works. Plus it means you can change the dimensions of the <code>Sprite</code> and always know that the anchor point will be in the place you expect without having to calculate the anchor point yourself.<div class=highlight><pre><span></span><code> <span class=c1>-- Zero ourselves out so we can get accurate width and height</span>
 <span class=n>self</span><span class=p>:</span><span class=n>setMatrix</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>

 <span class=c1>-- Calculate the actual position of the anchor</span>
 <span class=kd>local</span> <span class=n>anchorOffsetX</span> <span class=o>=</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointX</span> <span class=o>*</span> <span class=n>self</span><span class=p>:</span><span class=n>getWidth</span><span class=p>()</span>
 <span class=kd>local</span> <span class=n>anchorOffsetY</span> <span class=o>=</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointY</span> <span class=o>*</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>()</span>
</code></pre></div><p>The next set of operations apply our transformations to the Matrix, effectively concatenating them. They should all be pretty self explanatory if you've read my <a href=../../2013/05/the-beauty-of-using-matrices-to-apply.html>matrix overview</a>. In short, each is in turn concatenated onto the matrix much like characters can be concatenated together to form a string. First we set the position, then rotation and scale.<div class=highlight><pre><span></span><code> <span class=c1>-- set position</span>
 <span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_positionX</span><span class=p>,</span> <span class=n>self</span><span class=p>.</span><span class=n>_positionY</span><span class=p>)</span>

 <span class=c1>-- concatenate rotation and scale matrices</span>
 <span class=n>matrix</span><span class=p>:</span><span class=n>rotate</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_rotation</span><span class=p>)</span>
 <span class=n>matrix</span><span class=p>:</span><span class=n>scaleX</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_scaleX</span><span class=p>)</span>
 <span class=n>matrix</span><span class=p>:</span><span class=n>scaleY</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_scaleY</span><span class=p>)</span>
</code></pre></div><p>And finally the magic part, which is to offset by the negative of the anchor point.<div class=highlight><pre><span></span><code> <span class=c1>-- concatenate offset to new origin in modified coordinate space</span>
 <span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=o>-</span><span class=n>anchorOffsetX</span><span class=p>,</span> <span class=o>-</span><span class=n>anchorOffsetY</span><span class=p>)</span>
</code></pre></div><p>Since we concatenate the anchor point translate last, it is applied to the new coordinate space that is a result of the previous concatenations, and not based on the original coordinate space. Thus if you have an anchor point of [.5,.5] and rotate clockwise 45 degrees, the last translate will move the whole sprite along that 45 degree angle, or basically straight up. If you were to try this with the original Sprite:setPosition, it would move based on the original coordinate space, and so end up moving the sprite up and to the left, which is not what you wanted.<p>Lastly we apply our built-up matrix with <code>setMatrix()</code>, thus causing all the transforms to get applied. This will affect the current sprite as well as any children in the scene graph.<div class=highlight><pre><span></span><code> <span class=c1>-- Apply the new matrix</span>
 <span class=n>self</span><span class=p>:</span><span class=n>setMatrix</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>
</code></pre></div><p>This is our finished <code>_applyTransforms()</code> function.<div class=highlight><pre><span></span><code><span class=c1>-- New function to apply all transforms whenever anything changes</span>
<span class=kr>function</span> <span class=nc>AnchorSprite</span><span class=p>:</span><span class=nf>_applyTransforms</span><span class=p>()</span>
    <span class=c1>-- Create a new identity matrix</span>
    <span class=kd>local</span> <span class=n>matrix</span> <span class=o>=</span> <span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>()</span>

    <span class=c1>-- Zero ourselves out so we can get accurate width and height</span>
    <span class=n>self</span><span class=p>:</span><span class=n>setMatrix</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>

    <span class=c1>-- Calculate the actual position of the anchor</span>
    <span class=kd>local</span> <span class=n>anchorOffsetX</span> <span class=o>=</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointX</span> <span class=o>*</span> <span class=n>self</span><span class=p>:</span><span class=n>getWidth</span><span class=p>()</span>
    <span class=kd>local</span> <span class=n>anchorOffsetY</span> <span class=o>=</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointY</span> <span class=o>*</span> <span class=n>self</span><span class=p>:</span><span class=n>getHeight</span><span class=p>()</span>

    <span class=c1>-- set position</span>
    <span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_positionX</span><span class=p>,</span> <span class=n>self</span><span class=p>.</span><span class=n>_positionY</span><span class=p>)</span>

    <span class=c1>-- concatenate rotation and scale matrices</span>
    <span class=n>matrix</span><span class=p>:</span><span class=n>rotate</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_rotation</span><span class=p>)</span>
    <span class=n>matrix</span><span class=p>:</span><span class=n>scaleX</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_scaleX</span><span class=p>)</span>
    <span class=n>matrix</span><span class=p>:</span><span class=n>scaleY</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>_scaleY</span><span class=p>)</span>

    <span class=c1>-- concatenate offset to new origin in modified coordinate space</span>
    <span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=o>-</span><span class=n>anchorOffsetX</span><span class=p>,</span> <span class=o>-</span><span class=n>anchorOffsetY</span><span class=p>)</span>

    <span class=c1>-- Apply the new matrix</span>
    <span class=n>self</span><span class=p>:</span><span class=n>setMatrix</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><h3>Optimization</h3><p>So the last bit is to make this code only get put into place when an anchor point is set. This way, after you add <code>AnchorPoint.lua</code> to your project, it doesn't do anything to any <code>Sprite</code>s by default. Only those that you set an anchor point for with <code>setAnchorPoint</code> will start to intercept the transform methods, thus resulting in less overhead. This is why our functions so far have been in the <code>AnchorSprite</code> class. First step is to add the <code>setAnchorPoint()</code> method to the <code>Sprite</code> class along with our private member variables for storing the transforms.<div class=highlight><pre><span></span><code><span class=n>Sprite</span><span class=p>.</span><span class=n>_anchorSupport</span> <span class=o>=</span> <span class=kc>false</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_anchorBackup</span> <span class=o>=</span> <span class=p>{}</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_anchorPointX</span> <span class=o>=</span> <span class=mi>0</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_anchorPointY</span> <span class=o>=</span> <span class=mi>0</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_positionX</span> <span class=o>=</span> <span class=mi>0</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_positionY</span> <span class=o>=</span> <span class=mi>0</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_scaleX</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_scaleY</span> <span class=o>=</span> <span class=mi>1</span>
<span class=n>Sprite</span><span class=p>.</span><span class=n>_rotation</span> <span class=o>=</span> <span class=mi>0</span>

<span class=c1>-- New functions in Sprite for setting the anchor</span>
<span class=kr>function</span> <span class=nc>Sprite</span><span class=p>:</span><span class=nf>setAnchorPoint</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointX</span> <span class=o>=</span> <span class=n>x</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_anchorPointY</span> <span class=o>=</span> <span class=n>y</span> <span class=ow>or</span> <span class=n>x</span>

    <span class=kr>if</span> <span class=n>x</span> <span class=o>~=</span> <span class=mi>0</span> <span class=ow>or</span> <span class=n>y</span> <span class=o>~=</span> <span class=mi>0</span> <span class=ow>and</span> <span class=ow>not</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorSupport</span> <span class=kr>then</span>
    <span class=n>self</span><span class=p>:</span><span class=n>_enableAnchorSupport</span><span class=p>()</span>
    <span class=kr>elseif</span> <span class=n>x</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>y</span> <span class=o>==</span> <span class=mi>0</span> <span class=ow>and</span> <span class=n>self</span><span class=p>.</span><span class=n>_anchorSupport</span> <span class=kr>then</span>
    <span class=n>self</span><span class=p>:</span><span class=n>_disableAnchorSupport</span><span class=p>()</span>
    <span class=kr>end</span>
<span class=kr>end</span>
</code></pre></div><p>As you can see, this mainly calls a function called <code>_enableAnchorSupport()</code> that does all the work of modifying the Sprite class accordingly.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Sprite</span><span class=p>:</span><span class=nf>_enableAnchorSupport</span><span class=p>()</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_anchorSupport</span> <span class=o>=</span> <span class=kc>true</span>

    <span class=c1>-- Get current values</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_positionX</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getX</span><span class=p>()</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_positionY</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getY</span><span class=p>()</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_scaleX</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getScaleX</span><span class=p>()</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_scaleY</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getScaleY</span><span class=p>()</span>
    <span class=n>self</span><span class=p>.</span><span class=n>_rotation</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getRotation</span><span class=p>()</span>

    <span class=c1>-- Override Sprite functions with AnchorSprite versions</span>
    <span class=kr>for</span> <span class=n>k</span><span class=p>,</span><span class=n>v</span> <span class=kr>in</span> <span class=nb>pairs</span><span class=p>(</span><span class=n>AnchorSprite</span><span class=p>)</span> <span class=kr>do</span>
        <span class=kr>if</span> <span class=nb>type</span><span class=p>(</span><span class=n>v</span><span class=p>)</span> <span class=o>==</span> <span class=s2>"function"</span> <span class=kr>then</span>
            <span class=c1>--print("AnchorSprite", k, v)</span>
            <span class=kr>if</span> <span class=n>self</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=kr>then</span>
                <span class=c1>-- Backup existing function</span>
                <span class=n>self</span><span class=p>.</span><span class=n>_anchorBackup</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>Sprite</span><span class=p>[</span><span class=n>k</span><span class=p>]</span>
            <span class=kr>end</span>

            <span class=c1>-- Replace with AnchorSprite version</span>
            <span class=n>self</span><span class=p>[</span><span class=n>k</span><span class=p>]</span> <span class=o>=</span> <span class=n>v</span>
        <span class=kr>end</span>
    <span class=kr>end</span>

    <span class=n>self</span><span class=p>:</span><span class=n>_applyTransforms</span><span class=p>()</span>
<span class=kr>end</span>
</code></pre></div><p>This initializes our transform variables, then does a bit of magic of modifying the <code>Sprite</code> class itself. If you're unfamiliar with how Lua works, the thing to remember is that almost everything in Lua is a table. All classes are just a table, and values of that table can be variables or references to functions. So after backing up the original reference in <code>_anchorBackup</code> (a table), we just replace the reference in <code>Sprite</code>'s table with the one in <code>AnchorSprites</code> table. So now functions like <code>AnchorSprite:_applyTransforms</code> from earlier are now <code>Sprite:_applyTransforms</code>. The methods in <code>AnchorSprite</code> are never meant to be called while they're in <code>AnchorSprite</code>, and would actually throw weird errors. We make backups so that if the anchor is reset to [0,0], we can called <code>_disableAnchorSupport()</code> and return <code>Sprite</code> to the way it was.<h3>Result</h3><iframe allowfullscreen frameborder=0 height=315 src=http://www.youtube.com/embed/mM4SZwYuWOM?rel=0 style=float:right;margin-left:25px width=420></iframe><p>In the end, the result is that to the user, all we've done is added <code>Sprite:setAnchorPoint()</code> and <code>Sprite:getAnchorPoint()</code>, and everything just works. A <a href=https://github.com/nshafer/AnchorSprite>sample project is available</a> to see how it can be implemented and to show the results. To use it, simply include <a href=https://github.com/nshafer/AnchorSprite/blob/master/AnchorSprite.lua>AnchorSprite.lua</a> and <a href=https://github.com/nshafer/AnchorSprite/blob/master/Matrix.lua>Matrix.lua</a> into your project.<p>Of course, this is hopefully just a stopgap solution until Gideros builds this functionality in. Until then, this is one way to get around the limitation. Let me know if you find it useful.</div><section id=share-buttons><h3>Share this:</h3><ul><li><a class="btn btn-facebook" href="https://www.facebook.com/sharer/sharer.php?u=../../2013/06/anchorsprite-setting-anchor-point-on.html&t=AnchorSprite: Setting an anchor point on any Sprite" title="Share on Facebook" target=_blank> <i class="fa fa-facebook"></i> Facebook </a><li><a class="btn btn-twitter" href="https://twitter.com/intent/tweet?source=../../2013/06/anchorsprite-setting-anchor-point-on.html&text=AnchorSprite: Setting an anchor point on any Sprite" target=_blank title=Tweet> <i class="fa fa-twitter"></i> Twitter </a><li><a class="btn btn-reddit" href="http://www.reddit.com/submit?url=../../2013/06/anchorsprite-setting-anchor-point-on.html&title=AnchorSprite: Setting an anchor point on any Sprite" title="Submit to Reddit" target=_blank> <i class="fa fa-reddit"></i> Reddit </a><li><a class="btn btn-email" href="mailto:?subject=AnchorSprite: Setting an anchor point on any Sprite&body=Article+from+lchfkorea%0D%0A%0D%0A../../2013/06/anchorsprite-setting-anchor-point-on.html%0D%0A%0D%0AA class to allow you to set arbitrary anchor points on any sprite with little overhead." target=_blank title=Email> <i class="fa fa-envelope"></i> Email </a></ul></section></section><footer id=main-footer><section id=links><section><h3>Pages</h3><ul><li><a href=../../>Home</a><li><a href=../../archives.html>Archives</a><li><a href=../../pages/colophon.html>Colophon</a></ul></section><section><h3>Categories</h3><ul><li><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul></section><section><h3>Tags</h3><ul class=tag-cloud><li class=tag-1><a href=../../tag/android.html>android</a><li class=tag-1><a href=../../tag/css.html>css</a><li class="tag-1 tag-2"><a href=../../tag/django.html>django</a><li class=tag-1><a href=../../tag/docker.html>docker</a><li class="tag-1 tag-2"><a href=../../tag/elixir.html>elixir</a><li class="tag-1 tag-2 tag-3"><a href=../../tag/gideros.html>gideros</a><li class=tag-1><a href=../../tag/gulp.html>gulp</a><li class=tag-1><a href=../../tag/ios.html>ios</a><li class="tag-1 tag-2 tag-3 tag-4"><a href=../../tag/lua.html>lua</a><li class="tag-1 tag-2"><a href=../../tag/math.html>math</a><li class=tag-1><a href=../../tag/pelican.html>pelican</a><li class="tag-1 tag-2"><a href=../../tag/phoenix.html>phoenix</a><li class=tag-1><a href=../../tag/plug.html>plug</a><li class="tag-1 tag-2"><a href=../../tag/postgres.html>postgres</a><li class=tag-1><a href=../../tag/pycharm.html>pycharm</a><li class=tag-1><a href=../../tag/responsive.html>responsive</a><li class=tag-1><a href=../../tag/sass.html>sass</a><li class=tag-1><a href=../../tag/sublime-text.html>sublime-text</a><li class=tag-1><a href=../../tag/web-design.html>web design</a></ul></section><address><h3>Nathan Shafer</h3> <ul><li><a href=https://www.github.com/nshafer>Github</a><li><a href=http://www.normal-tech.com>Normal Technologies LLC</a><li><a href=http://www.typeingames.com>Type-in Games</a></ul></address></section><section id=subfooter><section id=copyright><p>© 2025 Nathan Shafer<p id=license>All work is licensed under a <a href=http://creativecommons.org/licenses/by/4.0/ rel=license>Creative Commons Attribution 4.0 International License</a> unless otherwise specified.</section><a title="Subscribe to my feed" href=http://feeds.feedburner.com/Lotechnica id=subscribe-link rel=alternate type=application/rss+xml> <img alt src=//feedburner.google.com/fb/images/pub/feed-icon32x32.png style=border:0> </a></section></footer>