<!doctype html><html lang=ko><meta charset=utf-8><meta content=ie=edge http-equiv=x-ua-compatible><meta name=description><meta content=width=device-width,height=device-height,initial-scale=1 name=viewport><title>lchfkorea</title><meta content=lua name=tags><meta content=gideros name=tags><meta content=math name=tags><meta content=lchfkorea property=og:site_name><meta content=article property=og:type><meta content="The beauty of using matrices to apply transformations to objects" property=og:title><meta content=../../2013/05/the-beauty-of-using-matrices-to-apply.html property=og:url><meta content="Using matrices and matrix math to apply transformations such as translate, rotate, scale and skew when programming graphics." property=og:description><meta content=2013-05-17 property=article:published_time><meta content=Graphics property=article:section><meta content=lua property=article:tag><meta content=gideros property=article:tag><meta content=math property=article:tag><meta content="DongBuem Lee" property=article:author><link href=../../theme/icons/apple-touch-icon-57x57.png rel=apple-touch-icon sizes=57x57><link href=../../theme/icons/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=../../theme/icons/apple-touch-icon-72x72.png rel=apple-touch-icon sizes=72x72><link href=../../theme/icons/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=../../theme/icons/apple-touch-icon-114x114.png rel=apple-touch-icon sizes=114x114><link href=../../theme/icons/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=../../theme/icons/apple-touch-icon-144x144.png rel=apple-touch-icon sizes=144x144><link href=../../theme/icons/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=../../theme/icons/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=../../theme/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=../../theme/icons/android-chrome-192x192.png rel=icon sizes=192x192 type=image/png><link href=../../theme/icons/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=../../theme/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=../../theme/icons/manifest.json rel=manifest><link rel="shortcut icon" href=../../theme/icons/favicon.ico><meta content=#00aba9 name=msapplication-TileColor><meta content=theme/icons/mstile-144x144.png name=msapplication-TileImage><meta content=theme/icons/browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><link href=https://fonts.googleapis.com/css?family=Open+Sans:400,700|Oswald:400,700 rel=stylesheet><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css rel=stylesheet><link href=../../theme/styles/theme.css rel=stylesheet><body><header id=main-header><ul id=main-menu role=nav><li class=active><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul><section id=masthead><img src=../../theme/images/toaster.png><h1><a href=../../>lchfkorea</a></h1><p>first trys by MindBuild</section></header><header id=article-header><div id=title><h2><a title="Permalink to The beauty of using matrices to apply transformations to objects" href=../../2013/05/the-beauty-of-using-matrices-to-apply.html rel=bookmark> The beauty of using matrices to apply transformations to objects </a></h2><footer><time class=published datetime=2013-05-17T00:00:00+09:00>5월 17, 2013</time></footer></div></header><section id=article><div class=markdown id=article-content><p>I have recently done a lot of work with matrix transformations, and I found the information on them either sparse, or over-complicated for what I needed. I had to pull together information from many places, split between mathematics focused information, programming reference, and forum posts. So I decided to hopefully write a simple but complete guide on how to understand matrix transformations for the purposes of applying them to computer graphics.<h3>Enter the matrix</h3><p>When dealing with 2D or 3D graphics programming, there will generally be a couple ways to apply transformations, such as translation (position), rotation, scaling, reflection and skewing (shearing.) There usually is a direct way, with calls to things like <code>setPosition()</code> and <code>setRotation()</code>. However, most frameworks also have another way, using matrix transformations. These are a more powerful way to affect the transformations of the object, and are computationally very quick as they only require addition and multiplication of a few values.<p>One big advantage is that you can string multiple transformations together one at a time, and they will be applied in the order you add them. To give a practical example, consider the SVG graphics standard for saving vector graphics. SVG files are XML files that use entities such as <code>&LTrect></code>, <code>&LTcircle></code> and <code>&LTpath></code>. Each of those defines through its attributes how to draw a rectangle, circle, or arbitrary path of lines and curves. Each of those entities can define a "transform" attribute which will contain transformations to apply to the shape right before its drawn. Sometimes it will just be a matrix definition.<p>So that's simple enough, however the tricky bit comes into play when you consider that SVG also supports a <code>&LTg></code> tag, short for "Group." These entities can contain any number of other groups or shapes in them. So you could end up with a deep hierarchy of shapes within groups within groups within groups... Each group can also define a "transform" attribute, to be applied to all groups and shapes within it, and so a shape could have many individual transforms or matrices applied to it. If you were to write an SVG parser (which I did recently and will be posting about soon,) then you would need to be able to concatenate all of those transformations together. With matrices, it's easy.<h3>What are matrices?</h3><p>A matrix is simply a two dimensional array of numbers. They are used in all kinds of scientific fields. For our purposes we just need to understand how they are defined and how to multiply (concatenate) them together. Matrices in graphics are always defined as $m \times n$ where $m$ is the number of rows, and $n$ is the number of columns. So a $2 \times 3$ matrix looks like this. $$ A = \begin{bmatrix} 1 & 2 & 3 \ 4 & 5 & 6 \ \end{bmatrix} $$<p>The method in which you access the individual elements of the matrix will vary toolkit to toolkit. One common method, and the one we'll use, is to reference them by $\text{m}_{mn}$ where 'm' is just the character 'm', '$m$' is the row number and '$n$' is the column number.<p>$$ A = \begin{bmatrix} \text{m}<em 12>{11} & \text{m}</em>} & \text{m<em 21>{13} \ \text{m}</em>} & \text{m<em 23>{22} & \text{m}</em> \ \end{bmatrix} $$<h3>2D and 3D transformations matrices</h3><p>First, we need to understand what dimensions our matrices are going to be in. Computer graphics generally use matrices of a size $m \times n$ where each of $m$ and $n$ are your dimension size plus one. So if you're working with 2D graphics, then you will be using 3x3 matrices, and 3D graphics use 4x4 matrices. For example, here is a 3x3 matrix used in 2D graphics and a 4x4 matrix used in 3D graphics.<table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} \text{m}_{11} & \text{m}_{12} & \text{tx} \\ \text{m}_{21} & \text{m}_{22} & \text{ty} \\ 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} \text{m}_{11} & \text{m}_{12} & \text{m}_{13} & \text{tx} \\ \text{m}_{21} & \text{m}_{22} & \text{m}_{23} & \text{ty} \\ \text{m}_{31} & \text{m}_{32} & \text{m}_{33} & \text{tz} \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>3x3 2D Affine Matrix<th align=center style=text-align:center>4x4 3D Affine Matrix</table><p>You'll notice that there are a few elements named differently, specifically, <em>tx</em>, <em>ty</em>, and <em>tz</em>. These elements always deal with the translation portion, so it's common to just name them that. For simplicity, we'll be dealing with just 2D 3x3 matrices from here on out, however everything here will also apply for 3D transforms, it's just you have an extra row and column to handle to work on the z-axis.<h3>Homogeneous Matrices</h3><p>The next thing we need to understand is why we have an extra row in each matrix. Transformation matrices are always "homogeneous." This is so the math is nice and tidy, and allows us to multiply them together and to individual points, which we'll get to later. We don't really need to understand it, thankfully. Just always know that you will have an extra row of zeroes and a one. The transformations we apply with these homogeneous matrices are called "affine transformations."<h3>Identity Matrices</h3><p>Just a quick note that there exists a matrix that is basically the equivalent of the number $1$, in that if you multiply a given matrix by an identity matrix, you'll always end up with the given matrix as the result. These identity matrices are used as the foundation of transform matrices, and are the reason the last row is zeroes followed by a one. An identity matrix is always zeroes except a "stripe" of ones going through it diagonally from top left to bottom right.<table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} 1 & 0 & 0 \\ 0 & 1 & 0 \\ 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>3x3 2D Affine Identity Matrix<th align=center style=text-align:center>4x4 3D Affine Identity Matrix</table><h3>Multiplication/Concatenation</h3><p>To go any further we first need to tackle the most complicated part of the new functionality that we're going to need, multiplication. Two matrices can be multiplied together to create a new matrix. The process is a pretty straightforward set of operations, but there are a few rules we have to abide by.<h4>Rule One: Order Matters!</h4><p>Matrix multiplication is non-commutative, which means that unlike normal numbers, multiplying the matrices $A \times B$ does not get the same result as $B \times A$. For this reason, it's often called concatenation instead of multiplication. We'll just call it multiplication from now on. But always remember that the order matters. Generally we take our existing matrix as the operand on the left, and multiply our new matrix as the operand on the right, thus concatenating it onto the end. If it helps, think of it as concatenating strings together. If you were building a sentence one word at a time, you would always concatenate the newest word onto the end of the string as you went, otherwise it would be unreadable. It's basically the same here.<h4>Rule Two: Matrices have to have the same inner dimensions</h4><p>To multiply two matrices together, their inner dimensions must match. This is best explained by an example.<p>$$ A \times B = \begin{bmatrix} 1 & 2 & 3 \ 4 & 5 & 6 \ \end{bmatrix} \times \begin{bmatrix} 1 & 2 \ 3 & 4 \ 5 & 6 \ \end{bmatrix} $$<p>This is a valid multiplication because the first matrix, A, is a 2x3 matrix, and B is a 3x2 matrix. So their inner dimensions, meaning the number of columns of A (3) is equal to the number of rows of B (3).<p>$$ 2 \times \fbox{$3 \times 3$} \times 2 $$<p>An invalid multiplication would look like:<p>$$ A \times B = \begin{bmatrix} 1 & 2 & 3 \ 4 & 5 & 6 \ \end{bmatrix} \times \begin{bmatrix} 1 & 2 & 3 \ 4 & 5 & 6 \ \end{bmatrix} $$<p>This is because the inner dimensions don't match<p>$$ 2 \times \fbox{$3 \times 2$} \times 3 $$<p>And now you know why transformation matrices are always homogeneous. If they didn't have that extra row of zeroes and a one, you wouldn't be able to multiply them together. A 3x3 matrix can always be multiplied by a 3x3 matrix in either direction because their inner dimensions will always match.<p><strong>Edit:</strong> Ok, so that's not the main reason they're homogeneous, just a nice by-product. I'm definitely not a mathematician, but as <a href=http://www.reddit.com/user/kyz>kyz</a> on reddit <a href=http://www.reddit.com/r/programming/comments/1ejqr0/guide_to_using_affine_transformation_matrices_to/ca154d0>pointed out</a>, this <a href=http://deltaorange.com/2012/03/08/the-truth-behind-homogenous-coordinates/>excellent explanation</a> was written by one, if you're really curious about the math behind it.<h4>Rule Three: Resulting matrix size</h4><p>Just a quick note that the resulting matrix after the operation will always be the same number of rows as the left matrix, and the same number of columns as the right matrix. So multiplying our 2x3 matrix by the 3x2 matrix from above will result in a 2x2 matrix. For our purposes, multiplying a 3x3 homogeneous transformation matrix by another will always result in a 3x3 result matrix. Another reason they are always homogeneous!<h4>Multiplication</h4><p>The actual act of multiplying the two matrices together involves finding the dot-product of each row of the first matrix by each column of the second matrix. As a reminder, a dot-product is where you multiply each element of an array by the corresponding element of a second array, then add the results together. A dot product of two arrays would look like.<p>$$ (a1, a2, a3) \cdot (b1, b2, b3) = (a1 \times b1 + a2 \times b2 + a3 \times b3) $$<p>With matrix multiplication we just do this multiple times for each element of the final matrix.<p>$$ \begin{bmatrix} \text{a}<em 12>{11} & \text{a}</em>} & \text{a<em 21>{tx} \ \text{a}</em>} & \text{a<em ty>{22} & \text{a}</em> \ 0 & 0 & 1 \end{bmatrix} \cdot \begin{bmatrix} \text{b}<em 12>{11} & \text{b}</em>} & \text{b<em 21>{tx} \ \text{b}</em>} & \text{b<em ty>{22} & \text{b}</em> \ 0 & 0 & 1 \end{bmatrix} $$<p>Would be<p>$$ \begin{bmatrix} \text{a}<em 11>{11} \times \text{b}</em>} + \text{a<em 21>{12} \times \text{b}</em>} + \text{a<em 11>{tx} \times 0 & \text{a}</em>} \times \text{b<em 12>{12} + \text{a}</em>} \times \text{b<em tx>{22} + \text{a}</em> \times 0 & \text{a}<em tx>{11} \times \text{b}</em>} + \text{a<em ty>{12} \times \text{b}</em>} + \text{a<em 21>{tx} \times 1 \ \text{a}</em>} \times \text{b<em 22>{11} + \text{a}</em>} \times \text{b<em ty>{21} + \text{a}</em> \times 0 & \text{a}<em 12>{21} \times \text{b}</em>} + \text{a<em 22>{22} \times \text{b}</em>} + \text{a<em 21>{ty} \times 0 & \text{a}</em>} \times \text{b<em 22>{tx} + \text{a}</em>} \times \text{b<em ty>{ty} + \text{a}</em> \times 1 \ 0 \times \text{b}<em 21>{11} + 0 \times \text{b}</em> + 1 \times 0 & 0 \times \text{b}<em 22>{12} + 0 \times \text{b}</em> + 1 \times 0 & 0 \times \text{b}<em ty>{tx} + 0 \times \text{b}</em> + 1 \times 1 \end{bmatrix} $$<h3>Application</h3><p>So now that we understand the basics of the matrices we're going to be working with, let's delve into some example code. For this blog I'm going to be using the <a href=http://www.giderosmobile.com/>Gideros framework</a> for a couple reasons. First, it's what I've been using to develop a lot lately, and thus it's what I've been using matrices in, but also because it doesn't have any real built-in matrix functionality. It has a built-in Matrix class, but you can only get and set the matrix of a given sprite. It doesn't have any functionality for manipulating those matrices like most frameworks do. So we're going to write our own.<p>However, credit is due to ar2rsawseen from the Gideros community for putting together a first draft of matrix functions in his <a href="https://github.com/ar2rsawseen/GiderosCodingEasy extensions">GiderosCodingEasy</a>. His code is where I started, however there were a few issues that prevented them from working properly in what I would consider a normal or standard fashion. He had originally ported that code from an ActionScript project that used matrix transforms in a non-standard way. So I modified his code to work in the same way that I saw in other frameworks. I guess that's what really helped me understand what was going on as I fixed those issues. He has since integrated my changes into his code.<h3>Matrix functionality in Gideros</h3><p>In Gideros, there is a Sprite class that every visible object is based on, whether it be text, shapes, bitmaps or whatever. This sprite class has a method for getting the current transform matrix, <code>Sprite:getMatrix()</code>, and a method for setting a new transform matrix, <code>Sprite:setMatrix(matrix)</code>, which is then applied to the sprite. <code>getMatrix()</code> returns an object of the Matrix class, and <code>setMatrix()</code> takes an object of the Matrix class. The Matrix class itself has many methods for getting and setting the individual elements of the 3x3 matrix, such as <code>getM11()</code>, <code>setM22()</code>, <code>getTx()</code>, <code>setTy()</code>, etc. What it is missing is any mathematical operations, specifically multiplication/concatenation, or any shortcuts to applying transforms, such as <em>translate</em>, <em>rotate</em>, <em>scale</em> or <em>skew</em>. So those are the parts we're going to fill in, and along the way gain a better understanding of how these all work together.<p>We're going to do this by adding our own methods to the built-in <code>Matrix</code> class. This is possible in Lua because nothing is protected, functions are a first-class type, and almost everything is a table (dictionary hash/array.) <code>Matrix</code> is just a table in the global namespace, with methods as keys and the actual functions as values. So we can just define our own methods like so.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>newMethod</span><span class=p>(</span><span class=n>var1</span><span class=p>,</span> <span class=n>var2</span><span class=p>)</span>
  <span class=c1>-- 'self' is automatically defined because we used the lua ':' syntactic sugar</span>
  <span class=nb>print</span><span class=p>(</span><span class=s2>"Matrix:newMethod called"</span><span class=p>,</span> <span class=n>self</span><span class=p>,</span> <span class=n>var1</span><span class=p>,</span> <span class=n>var2</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><p>Once our code is included in a project, you won't be able to tell that <code>newMethod</code> wasn't always there.<h3>Multiplication Method</h3><p>So our first and probably most important extension to the <code>Matrix</code> class will be a <code>multiply()</code> method that takes a matrix as its argument and multiplies itself by that matrix using the formula we discussed above. We can skip the parts of the dot product that always add a 0 to avoid unnecessary calculations.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>multiply</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>m11</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>m12</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>m21</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>m22</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>tx</span>  <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getTx</span><span class=p>()</span>  <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getTy</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getTx</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>ty</span>  <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getTx</span><span class=p>()</span>  <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span><span class=o>*</span><span class=n>matrix</span><span class=p>:</span><span class=n>getTy</span><span class=p>()</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getTy</span><span class=p>()</span>
  <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>setElements</span><span class=p>(</span><span class=n>m11</span><span class=p>,</span> <span class=n>m12</span><span class=p>,</span> <span class=n>m21</span><span class=p>,</span> <span class=n>m22</span><span class=p>,</span> <span class=n>tx</span><span class=p>,</span> <span class=n>ty</span><span class=p>)</span>
<span class=kr>end</span>
</code></pre></div><p>This is now our foundation upon which we can build everything else. Please note that Gideros <code>Matrix</code> methods take the arguments in a slightly odd order: m11, m12, m21, m22, tx, ty.<h3>Translation Method</h3><p>Translation is the simplest matrix to apply. Given a <em>tx</em> and <em>ty</em> as distance to translate x and y by, we simply build the following matrix based on an identity matrix, then multiply it.<p>$$ \begin{bmatrix} 1 & 0 & tx \ 0 & 1 & ty \ 0 & 0 & 1 \ \end{bmatrix} $$<p>This is what our <code>translate()</code> method will look like.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>translate</span><span class=p>(</span><span class=n>x</span><span class=p>,</span><span class=n>y</span><span class=p>)</span>
  <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>multiply</span><span class=p>(</span><span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>x</span><span class=p>,</span> <span class=n>y</span> <span class=ow>or</span> <span class=n>x</span><span class=p>))</span>
<span class=kr>end</span>
</code></pre></div><h3>Scaling Method</h3><p>Scaling is also pretty simple. Given <em>sx</em> and <em>sy</em> as the amount to scale x and y by, we build the following matrix based on an identity matrix, then multiply it.<p>$$ \begin{bmatrix} sx & 0 & 0 \ 0 & sy & 0 \ 0 & 0 & 1 \ \end{bmatrix} $$<p>And here is the code that will do that.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>scale</span><span class=p>(</span><span class=n>sx</span><span class=p>,</span><span class=n>sy</span><span class=p>)</span>
  <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>multiply</span><span class=p>(</span><span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=n>sx</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sy</span> <span class=ow>or</span> <span class=n>sx</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
<span class=kr>end</span>
</code></pre></div><h3>Rotation Method</h3><p>Rotation is a little more involved, but still isn't bad. Given the angle <em>a</em> in radians, our rotation translation matrix looks like this.<p>$$ \begin{bmatrix} \cos(a) & -\sin(a) & 0 \ \sin(a) & \cos(0) & 0 \ 0 & 0 & 1 \ \end{bmatrix} $$<p>Since Gideros functions always deal in degrees and not radians, we'll write our function to take the angle in degrees, then convert to radians for building the matrix.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>rotate</span><span class=p>(</span><span class=n>deg</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>rad</span> <span class=o>=</span> <span class=nb>math.rad</span><span class=p>(</span><span class=n>deg</span><span class=p>)</span>
  <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>multiply</span><span class=p>(</span><span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=nb>math.cos</span><span class=p>(</span><span class=n>rad</span><span class=p>),</span> <span class=o>-</span><span class=nb>math.sin</span><span class=p>(</span><span class=n>rad</span><span class=p>),</span> <span class=nb>math.sin</span><span class=p>(</span><span class=n>rad</span><span class=p>),</span> <span class=nb>math.cos</span><span class=p>(</span><span class=n>rad</span><span class=p>),</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
<span class=kr>end</span>
</code></pre></div><h3>Skew Method</h3><p>Skew is similar to rotation. Given an angle <em>ax</em> to skew on the x-axis, and an angle <em>ay</em> to skew on the y-axis, we construct the matrix as such.<p>$$ \begin{bmatrix} 1 & \tan(ax) & 0 \ \tan(ay) & 1 & 0 \ 0 & 0 & 1 \ \end{bmatrix} $$<p>Similar to rotation, we'll take our arguments in degrees and convert to radians for the calculation.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>skew</span><span class=p>(</span><span class=n>xAng</span><span class=p>,</span><span class=n>yAng</span><span class=p>)</span>
  <span class=n>xAng</span> <span class=o>=</span> <span class=nb>math.rad</span><span class=p>(</span><span class=n>xAng</span><span class=p>)</span>
  <span class=n>yAng</span> <span class=o>=</span> <span class=nb>math.rad</span><span class=p>(</span><span class=n>yAng</span> <span class=ow>or</span> <span class=n>xAng</span><span class=p>)</span>
  <span class=kr>return</span> <span class=n>self</span><span class=p>:</span><span class=n>multiply</span><span class=p>(</span><span class=n>Matrix</span><span class=p>.</span><span class=n>new</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>math.tan</span><span class=p>(</span><span class=n>xAng</span><span class=p>),</span> <span class=nb>math.tan</span><span class=p>(</span><span class=n>yAng</span><span class=p>),</span> <span class=mi>1</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>))</span>
<span class=kr>end</span>
</code></pre></div><h3>Reflection</h3><p>Reflecting on the x or y axis is as simple as applying a negative scale in either direction.<div class=highlight><pre><span></span><code><span class=c1>-- Flip or mirror on the horizontal axis.</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>setScaleX</span><span class=p>(</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</code></pre></div><h3>Applying a transformation matrix to an arbitrary point</h3><p>Lastly, it comes in handy every once in a while to be able to apply a given transformation matrix to a single point. This is mainly used to translate between an original coordinate space and the transformed coordinate space. Points can be represented as a 3x1 matrix.<p>$$ p = \begin{bmatrix} x \ y \ 1 \ \end{bmatrix} $$<p>This means we can multiply a 3x3 transformation matrix times a point, but not the other way, since the inner products wouldn't match. So this multiplication simply looks like this.<p>$$ \begin{bmatrix} \text{a}<em 12>{11} & \text{a}</em>} & \text{a<em 21>{tx} \ \text{a}</em>} & \text{a<em ty>{22} & \text{a}</em> \ 0 & 0 & 1 \ \end{bmatrix} \cdot \begin{bmatrix} x \ y \ 1 \ \end{bmatrix} = \begin{bmatrix} \text{a}<em 12>{11} \times x + \text{a}</em>} \times y + \text{a<em 21>{tx} \times 1 \ \text{a}</em>} \times x + \text{a<em ty>{22} \times y + \text{a}</em> \times 1 \ 0 \times x + 0 \times y + 1 \times 1 \ \end{bmatrix} $$<p>Converting this formula to code will result in this method.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Matrix</span><span class=p>:</span><span class=nf>applyToPoint</span><span class=p>(</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>newX</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM11</span><span class=p>()</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM12</span><span class=p>()</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getTx</span><span class=p>()</span>
  <span class=kd>local</span> <span class=n>newY</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>getM21</span><span class=p>()</span> <span class=o>*</span> <span class=n>x</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getM22</span><span class=p>()</span> <span class=o>*</span> <span class=n>y</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>getTy</span><span class=p>()</span>
  <span class=kr>return</span> <span class=n>newX</span><span class=p>,</span> <span class=n>newY</span>
<span class=kr>end</span>
</code></pre></div><h3>Putting it all together</h3><p>Once this is all in place, the following example code is an idea of what is possible.<div class=highlight><pre><span></span><code><span class=c1>-- Create a rectangle Shape which inherits from Sprite sized 100 pixels wide and 100 pixels tall</span>
<span class=kd>local</span> <span class=n>box</span> <span class=o>=</span> <span class=n>createBox</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span><span class=mi>100</span><span class=p>)</span>

<span class=c1>-- Set a new position for the box.</span>
<span class=n>box</span><span class=p>:</span><span class=n>setPosition</span><span class=p>(</span><span class=mi>100</span><span class=p>,</span><span class=mi>200</span><span class=p>)</span>

<span class=c1>-- This gets the current matrix, which includes the new position we just set</span>
<span class=kd>local</span> <span class=n>matrix</span> <span class=o>=</span> <span class=n>box</span><span class=p>:</span><span class=n>getMatrix</span><span class=p>()</span>

<span class=c1>-- Move to our new anchor point relative to current position</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=mi>50</span><span class=p>,</span><span class=mi>50</span><span class=p>)</span>

<span class=c1>-- Rotate by 45 degrees</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>rotate</span><span class=p>(</span><span class=mi>45</span><span class=p>)</span>

<span class=c1>-- Scale by 150%</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>scale</span><span class=p>(</span><span class=mf>1.5</span><span class=p>)</span>

<span class=c1>-- Skew the x axis by 20 degrees</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>skew</span><span class=p>(</span><span class=mi>20</span><span class=p>,</span> <span class=mi>0</span><span class=p>)</span>

<span class=c1>-- Put it back</span>
<span class=n>matrix</span><span class=p>:</span><span class=n>translate</span><span class=p>(</span><span class=o>-</span><span class=mi>50</span><span class=p>,</span><span class=o>-</span><span class=mi>50</span><span class=p>)</span>

<span class=c1>-- Apply our new concatenated transform to the sprite</span>
<span class=n>box</span><span class=p>:</span><span class=n>setMatrix</span><span class=p>(</span><span class=n>matrix</span><span class=p>)</span>
</code></pre></div><h3>Full code and Sample project</h3><p><img alt="Screenshot of AnchorSprite implementation" class=pull-right src=../../images/beauty-matrix-transforms/Matrix.png><p>I have made the full code to this Matrix extension available on Github. You can view just the <a href=https://github.com/nshafer/Matrix/blob/master/Matrix.lua>Matrix class extensions</a> or a full <a href=https://github.com/nshafer/Matrix>example Gideros project</a> that shows the code in action. The code is the same as in this post, plus a few extra convenience methods.<h3>References</h3><p>I'd like to thank the following wonderful references that I read when I was learning all of this.<ul><li><a href=http://en.wikipedia.org/wiki/Matrix_(mathematics)>Wikipedia: Matrix (mathematics)</a><li><a href=http://en.wikipedia.org/wiki/Transformation_matrix>Wikipedia: Transformation matrix</a><li><a href=http://www.willamette.edu/~gorr/classes/GeneralGraphics/Transforms/transforms2d.htm>2D Transformations</a><li><a href=http://www.giderosmobile.com>Gideros Mobile Framework</a><li><a href=https://github.com/ar2rsawseen/GiderosCodingEasy>ar2rsawseen's GiderosCodingEasy</a><li><a href=http://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace>W3C SVG Standards section on transformations</a><li><a href=http://msdn.microsoft.com/en-us/library/microsoft.xna.framework.matrix.aspx>Microsoft XNA Library - Matrix class</a><li><a href=http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Reference/CGAffineTransform/Reference/reference.html>Apple CGAffineTransform Reference</a><li><a href=http://stackoverflow.com/>Many posts on StackOverflow.com</a><li><a href=http://metamerist.com/excanvas/example34.htm>Matrices in HTML Applet - How I generated the HTML for my matrices</a></ul><h3>Real world uses</h3><p>I'll soon post followups to this post showing a couple examples of how I used this new Matrix class to implement a movable anchor for Gideros Sprites, and to parse SVG files and all their transforms. For example, here's my <a href=https://github.com/nshafer/AnchorSprite>AnchorSprite implementation</a>, which supports moving the anchor for a sprite from [0,0] to anywhere you want, and affects all position, rotation, scale and skew operations.<p><img alt="Screenshot of AnchorSprite implementation" src=../../images/beauty-matrix-transforms/AnchorSprite_cap.png><h3>More on 3D</h3><p>When applying these same techniques to 3D, most of the basics are the same, however you have bigger matrices and one more axis to handle. Matrix multiplication still works the same, the matrices are still homogeneous, identity matrices are the same. What will be different are the types of matrices you construct to do your transformations. Here is just a quick list of these matrices.<table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & tx \\ 0 & 1 & 0 & ty \\ 0 & 0 & 1 & tz \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} sx & 0 & 0 & 0 \\ 0 & sy & 0 & 0 \\ 0 & 0 & sz & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>4x4 3D Translation Matrix<th align=center style=text-align:center>4x4 3D Scale Matrix</table><table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & \cos(a) & -\sin(a) & 0 \\ 0 & \sin(a) & \cos(a) & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} \cos(a) & 0 & \sin(a) & 0 \\ 0 & 1 & 0 & 0 \\ -\sin(a) & 0 & \cos(a) & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} \cos(a) & -\sin(a) & 0 & 0 \\ \sin(a) & \cos(a) & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>4x4 3D x-axis Rotation Matrix<th align=center style=text-align:center>4x4 3D y-axis Rotation Matrix<th align=center style=text-align:center>4x4 3D z-axis Rotation Matrix</table><table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ \tan(a) & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ \tan(a) & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} 1 & \tan(a) & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>4x4 3D xz-axis Skew Matrix<th align=center style=text-align:center>4x4 3D zx-axis Skew Matrix<th align=center style=text-align:center>4x4 3D yz-axis Skew Matrix</table><table style="width:100%;margin:2em auto"><tbody><tr><td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & \tan(a) & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} 1 & 0 & \tan(a) & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<td align=center>$$ \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 1 & \tan(a) & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \\ \end{bmatrix} $$<tr><th align=center style=text-align:center>4x4 3D zy-axis Skew Matrix<th align=center style=text-align:center>4x4 3D xy-axis Skew Matrix<th align=center style=text-align:center>4x4 3D yx-axis Skew Matrix</table><p>Points in 3D are a 4x1 of $[x,y,z,1]^T$, and the math to apply them to a transform is the same as above, just one more axis to determine. Here are some further resources specific to 3D transformations.<ul><li><a href=http://en.wikipedia.org/wiki/Transformation_matrix#Examples_in_3D_graphics>Wikipedia 3D Transformations</a><li><a href=http://en.wikipedia.org/wiki/Rotation_matrix#In_three_dimensions>Wikipedia 3D rotations</a><li><a href=http://en.wikipedia.org/wiki/Scaling_(geometry)#Using_homogeneous_coordinates>Wikipedia 3D Scaling matrices</a><li><a href=http://stackoverflow.com/questions/13206220/3d-skew-transformation-matrix-along-one-coordinate-axis>3D skew matrices (Diagrams are in the order of the examples above)</a></ul></div><section id=share-buttons><h3>Share this:</h3><ul><li><a class="btn btn-facebook" href="https://www.facebook.com/sharer/sharer.php?u=../../2013/05/the-beauty-of-using-matrices-to-apply.html&t=The beauty of using matrices to apply transformations to objects" title="Share on Facebook" target=_blank> <i class="fa fa-facebook"></i> Facebook </a><li><a class="btn btn-twitter" href="https://twitter.com/intent/tweet?source=../../2013/05/the-beauty-of-using-matrices-to-apply.html&text=The beauty of using matrices to apply transformations to objects" target=_blank title=Tweet> <i class="fa fa-twitter"></i> Twitter </a><li><a class="btn btn-reddit" href="http://www.reddit.com/submit?url=../../2013/05/the-beauty-of-using-matrices-to-apply.html&title=The beauty of using matrices to apply transformations to objects" title="Submit to Reddit" target=_blank> <i class="fa fa-reddit"></i> Reddit </a><li><a class="btn btn-email" href="mailto:?subject=The beauty of using matrices to apply transformations to objects&body=Article+from+lchfkorea%0D%0A%0D%0A../../2013/05/the-beauty-of-using-matrices-to-apply.html%0D%0A%0D%0AUsing matrices and matrix math to apply transformations such as translate, rotate, scale and skew when programming graphics." target=_blank title=Email> <i class="fa fa-envelope"></i> Email </a></ul></section></section><footer id=main-footer><section id=links><section><h3>Pages</h3><ul><li><a href=../../>Home</a><li><a href=../../archives.html>Archives</a><li><a href=../../pages/colophon.html>Colophon</a></ul></section><section><h3>Categories</h3><ul><li><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul></section><section><h3>Tags</h3><ul class=tag-cloud><li class=tag-1><a href=../../tag/android.html>android</a><li class=tag-1><a href=../../tag/css.html>css</a><li class="tag-1 tag-2"><a href=../../tag/django.html>django</a><li class=tag-1><a href=../../tag/docker.html>docker</a><li class="tag-1 tag-2"><a href=../../tag/elixir.html>elixir</a><li class="tag-1 tag-2 tag-3"><a href=../../tag/gideros.html>gideros</a><li class=tag-1><a href=../../tag/gulp.html>gulp</a><li class=tag-1><a href=../../tag/ios.html>ios</a><li class="tag-1 tag-2 tag-3 tag-4"><a href=../../tag/lua.html>lua</a><li class="tag-1 tag-2"><a href=../../tag/math.html>math</a><li class=tag-1><a href=../../tag/pelican.html>pelican</a><li class="tag-1 tag-2"><a href=../../tag/phoenix.html>phoenix</a><li class=tag-1><a href=../../tag/plug.html>plug</a><li class="tag-1 tag-2"><a href=../../tag/postgres.html>postgres</a><li class=tag-1><a href=../../tag/pycharm.html>pycharm</a><li class=tag-1><a href=../../tag/responsive.html>responsive</a><li class=tag-1><a href=../../tag/sass.html>sass</a><li class=tag-1><a href=../../tag/sublime-text.html>sublime-text</a><li class=tag-1><a href=../../tag/web-design.html>web design</a></ul></section><address><h3>Nathan Shafer</h3> <ul><li><a href=https://www.github.com/nshafer>Github</a><li><a href=http://www.normal-tech.com>Normal Technologies LLC</a><li><a href=http://www.typeingames.com>Type-in Games</a></ul></address></section><section id=subfooter><section id=copyright><p>© 2025 Nathan Shafer<p id=license>All work is licensed under a <a href=http://creativecommons.org/licenses/by/4.0/ rel=license>Creative Commons Attribution 4.0 International License</a> unless otherwise specified.</section><a title="Subscribe to my feed" href=http://feeds.feedburner.com/Lotechnica id=subscribe-link rel=alternate type=application/rss+xml> <img alt src=//feedburner.google.com/fb/images/pub/feed-icon32x32.png style=border:0> </a></section></footer>