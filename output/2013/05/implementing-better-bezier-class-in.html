<!doctype html><html lang=ko><meta charset=utf-8><meta content=ie=edge http-equiv=x-ua-compatible><meta name=description><meta content=width=device-width,height=device-height,initial-scale=1 name=viewport><title>lchfkorea</title><meta content=lua name=tags><meta content=gideros name=tags><meta content=math name=tags><meta content=lchfkorea property=og:site_name><meta content=article property=og:type><meta content="Implementing a better Bezier class in Gideros" property=og:title><meta content=../../2013/05/implementing-better-bezier-class-in.html property=og:url><meta content="Optimizing a basic Bezier curve class for better performance by selectively reducing point counts while maintaining high quality, smooth curves." property=og:description><meta content=2013-05-03 property=article:published_time><meta content=Graphics property=article:section><meta content=lua property=article:tag><meta content=gideros property=article:tag><meta content=math property=article:tag><meta content="DongBuem Lee" property=article:author><link href=../../theme/icons/apple-touch-icon-57x57.png rel=apple-touch-icon sizes=57x57><link href=../../theme/icons/apple-touch-icon-60x60.png rel=apple-touch-icon sizes=60x60><link href=../../theme/icons/apple-touch-icon-72x72.png rel=apple-touch-icon sizes=72x72><link href=../../theme/icons/apple-touch-icon-76x76.png rel=apple-touch-icon sizes=76x76><link href=../../theme/icons/apple-touch-icon-114x114.png rel=apple-touch-icon sizes=114x114><link href=../../theme/icons/apple-touch-icon-120x120.png rel=apple-touch-icon sizes=120x120><link href=../../theme/icons/apple-touch-icon-144x144.png rel=apple-touch-icon sizes=144x144><link href=../../theme/icons/apple-touch-icon-152x152.png rel=apple-touch-icon sizes=152x152><link href=../../theme/icons/apple-touch-icon-180x180.png rel=apple-touch-icon sizes=180x180><link href=../../theme/icons/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=../../theme/icons/android-chrome-192x192.png rel=icon sizes=192x192 type=image/png><link href=../../theme/icons/favicon-96x96.png rel=icon sizes=96x96 type=image/png><link href=../../theme/icons/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=../../theme/icons/manifest.json rel=manifest><link rel="shortcut icon" href=../../theme/icons/favicon.ico><meta content=#00aba9 name=msapplication-TileColor><meta content=theme/icons/mstile-144x144.png name=msapplication-TileImage><meta content=theme/icons/browserconfig.xml name=msapplication-config><meta content=#ffffff name=theme-color><link href=https://fonts.googleapis.com/css?family=Open+Sans:400,700|Oswald:400,700 rel=stylesheet><link href=https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css rel=stylesheet><link href=../../theme/styles/theme.css rel=stylesheet><body><header id=main-header><ul id=main-menu role=nav><li class=active><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul><section id=masthead><img src=../../theme/images/toaster.png><h1><a href=../../>lchfkorea</a></h1><p>first trys by MindBuild</section></header><header id=article-header><div id=title><h2><a title="Permalink to Implementing a better Bezier class in Gideros" href=../../2013/05/implementing-better-bezier-class-in.html rel=bookmark> Implementing a better Bezier class in Gideros </a></h2><footer><time class=published datetime=2013-05-03T00:00:00+09:00>5월 3, 2013</time></footer></div></header><section id=article><div class=markdown id=article-content><p>Bezier curves are nothing new, and there is a lot of good code out there that implements them well. I started with <a href=http://paulbourke.net/geometry/bezier/>Paul Burke's algorithm</a>, mainly because someone had <a href=http://www.giderosmobile.com/forum/discussion/461/bezier-curve-code>already ported it to Gideros</a>. This algorithm works quite well, is fast, and is simple enough to understand. However, I thought I could figure out how to improve on my implementation at least a little, without switching to a much more complicated algorithm. My goals were to produce curves with points in all the optimal places resulting in it being smooth, but with as few points as possible. So this is what I've come up with.<p>First, here is my naive implementation.<div class=highlight><pre><span></span><code><span class=n>Bezier</span> <span class=o>=</span> <span class=n>Core</span><span class=p>.</span><span class=n>class</span><span class=p>(</span><span class=n>Shape</span><span class=p>)</span>

<span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>createCubicCurve</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span> <span class=n>p4</span><span class=p>,</span> <span class=n>steps</span><span class=p>)</span>
  <span class=n>self</span><span class=p>.</span><span class=n>points</span> <span class=o>=</span> <span class=p>{}</span>
  <span class=n>steps</span> <span class=o>=</span> <span class=n>steps</span> <span class=ow>or</span> <span class=mi>100</span>
  <span class=kr>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>,</span> <span class=n>steps</span> <span class=kr>do</span>
    <span class=nb>table.insert</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>,</span> <span class=n>self</span><span class=p>:</span><span class=n>bezier4</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span> <span class=n>p4</span><span class=p>,</span> <span class=n>i</span><span class=o>/</span><span class=n>steps</span><span class=p>))</span>
  <span class=kr>end</span>
<span class=kr>end</span>

<span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>bezier4</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span><span class=n>p2</span><span class=p>,</span><span class=n>p3</span><span class=p>,</span><span class=n>p4</span><span class=p>,</span><span class=n>mu</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>mum1</span><span class=p>,</span><span class=n>mum13</span><span class=p>,</span><span class=n>mu3</span><span class=p>;</span>
  <span class=kd>local</span> <span class=n>p</span> <span class=o>=</span> <span class=p>{}</span>

  <span class=n>mum1</span> <span class=o>=</span> <span class=mi>1</span> <span class=o>-</span> <span class=n>mu</span>
  <span class=n>mum13</span> <span class=o>=</span> <span class=n>mum1</span> <span class=o>*</span> <span class=n>mum1</span> <span class=o>*</span> <span class=n>mum1</span>
  <span class=n>mu3</span> <span class=o>=</span> <span class=n>mu</span> <span class=o>*</span> <span class=n>mu</span> <span class=o>*</span> <span class=n>mu</span>

  <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>=</span> <span class=n>mum13</span><span class=o>*</span><span class=n>p1</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>p2</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>p3</span><span class=p>.</span><span class=n>x</span> <span class=o>+</span> <span class=n>mu3</span><span class=o>*</span><span class=n>p4</span><span class=p>.</span><span class=n>x</span>
  <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>=</span> <span class=n>mum13</span><span class=o>*</span><span class=n>p1</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>p2</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=mi>3</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mu</span><span class=o>*</span><span class=n>mum1</span><span class=o>*</span><span class=n>p3</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>mu3</span><span class=o>*</span><span class=n>p4</span><span class=p>.</span><span class=n>y</span>
  <span class=c1>--p.z = mum13*p1.z + 3*mu*mum1*mum1*p2.z + 3*mu*mu*mum1*p3.z + mu3*p4.z</span>

  <span class=kr>return</span> <span class=n>p</span> 
<span class=kr>end</span>
</code></pre></div><p>This gives us 101 points for the cubic curve {100,100}, {800,250}, {800,100}, {150,200}. This isn't too bad, as it gives us enough for it to be smooth, but using way too many points. Much longer curves will end up with too-few points and could appear jagged, and much shorter curves will end up with too many.<p><img alt="Steps: 100, Epsilon: 0" src=../../images/better-bezier-class-gideros/steps100_epsilon0.png><h3>Automatic estimation of steps</h3><p>First, I wanted to figure out a way to estimate the number of steps for a given curve, based on it's length instead of just always using 100. This way shorter curves would have fewer points, avoiding unnecessary overhead, and longer curves would have more points, smoothing them out. The problem is, we don't really know the length until we actually calculate it. However, we can guess based on the distances of all of the points. Basically we estimate it at 10% (by default) of the total distance between all points. This seems to work fine in my tests. If you want more points, just increase the percentage.<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>estimateSteps</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>,</span> <span class=n>p4</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>distance</span> <span class=o>=</span> <span class=mi>0</span>
  <span class=kr>if</span> <span class=n>p1</span> <span class=ow>and</span> <span class=n>p2</span> <span class=kr>then</span>
    <span class=n>distance</span> <span class=o>=</span> <span class=n>distance</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>pointDistance</span><span class=p>(</span><span class=n>p1</span><span class=p>,</span> <span class=n>p2</span><span class=p>)</span>
  <span class=kr>end</span>
  <span class=kr>if</span> <span class=n>p2</span> <span class=ow>and</span> <span class=n>p3</span> <span class=kr>then</span>
    <span class=n>distance</span> <span class=o>=</span> <span class=n>distance</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>pointDistance</span><span class=p>(</span><span class=n>p2</span><span class=p>,</span> <span class=n>p3</span><span class=p>)</span>
  <span class=kr>end</span>
  <span class=kr>if</span> <span class=n>p3</span> <span class=ow>and</span> <span class=n>p4</span> <span class=kr>then</span>
    <span class=n>distance</span> <span class=o>=</span> <span class=n>distance</span> <span class=o>+</span> <span class=n>self</span><span class=p>:</span><span class=n>pointDistance</span><span class=p>(</span><span class=n>p3</span><span class=p>,</span> <span class=n>p4</span><span class=p>)</span>
  <span class=kr>end</span>

  <span class=kr>return</span> <span class=nb>math.max</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=nb>math.floor</span><span class=p>(</span><span class=n>distance</span> <span class=o>*</span> <span class=n>self</span><span class=p>.</span><span class=n>autoStepScale</span><span class=p>))</span>
<span class=kr>end</span>
</code></pre></div><p>This gives us 153 points for this particular curve. This will help smooth out tight turns in curves much larger than this, but is way too many for most parts of the curve, such as the long straight parts. So by itself, this isn't much of a solution.<p><img alt="Steps: auto, Epsilon: 0" src=../../images/better-bezier-class-gideros/stepsauto_epsilon0.png><h3>Reduction of points</h3><p>So the last thing I wanted to do was to get rid of unnecessary points. If a part of the curve is pretty much straight, we don't need so many points to somewhat accurately describe it. After some searching around I found the <a href=http://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm>Ramer-Douglas-Peucker algorithm</a> for reducing points in a curve, along with an <a href=http://quangnle.wordpress.com/2012/12/30/corona-sdk-curve-fitting-1-implementation-of-ramer-douglas-peucker-algorithm-to-reduce-points-of-a-curve/>implementation for Corona SDK</a>. So now we can add a <code>reduce()</code> method. It recursively figures out redundant points that are less than epsilon distance from a line comprised of the current segment it's looking at. After it's done, we throw away all points that aren't marked as, "keep."<div class=highlight><pre><span></span><code><span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>reduce</span><span class=p>(</span><span class=n>epsilon</span><span class=p>)</span>
  <span class=n>epsilon</span> <span class=o>=</span> <span class=n>epsilon</span> <span class=ow>or</span> <span class=mf>.1</span>

  <span class=kr>if</span> <span class=o>#</span><span class=n>self</span><span class=p>.</span><span class=n>points</span> <span class=o>></span> <span class=mi>1</span> <span class=kr>then</span>
    <span class=c1>-- Keep first and last</span>
    <span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=mi>1</span><span class=p>].</span><span class=n>keep</span> <span class=o>=</span> <span class=kc>true</span>
    <span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=o>#</span><span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>].</span><span class=n>keep</span> <span class=o>=</span> <span class=kc>true</span>

    <span class=c1>-- Figure out the rest</span>
    <span class=n>self</span><span class=p>:</span><span class=n>douglasPeucker</span><span class=p>(</span><span class=mi>1</span><span class=p>,</span> <span class=o>#</span><span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>,</span> <span class=n>epsilon</span><span class=p>)</span>
  <span class=kr>end</span>

  <span class=c1>-- Replace point list with only those that are marked to keep</span>
  <span class=kd>local</span> <span class=n>old</span> <span class=o>=</span> <span class=n>self</span><span class=p>.</span><span class=n>points</span>
  <span class=n>self</span><span class=p>.</span><span class=n>points</span> <span class=o>=</span> <span class=p>{}</span>

  <span class=kr>for</span> <span class=n>i</span><span class=p>,</span><span class=n>point</span> <span class=kr>in</span> <span class=nb>ipairs</span><span class=p>(</span><span class=n>old</span><span class=p>)</span> <span class=kr>do</span>
    <span class=kr>if</span> <span class=n>point</span><span class=p>.</span><span class=n>keep</span> <span class=kr>then</span>
      <span class=nb>table.insert</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>,</span> <span class=p>{</span><span class=n>x</span><span class=o>=</span><span class=n>point</span><span class=p>.</span><span class=n>x</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=n>point</span><span class=p>.</span><span class=n>y</span><span class=p>})</span>
    <span class=kr>end</span>
  <span class=kr>end</span>
<span class=kr>end</span>

<span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>douglasPeucker</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>last</span><span class=p>,</span> <span class=n>epsilon</span><span class=p>)</span>
  <span class=kd>local</span> <span class=n>dmax</span> <span class=o>=</span> <span class=mi>0</span>
  <span class=kd>local</span> <span class=n>index</span> <span class=o>=</span> <span class=mi>0</span>

  <span class=kr>for</span> <span class=n>i</span><span class=o>=</span><span class=n>first</span><span class=o>+</span><span class=mi>1</span><span class=p>,</span> <span class=n>last</span><span class=o>-</span><span class=mi>1</span> <span class=kr>do</span>
    <span class=kd>local</span> <span class=n>d</span> <span class=o>=</span> <span class=n>self</span><span class=p>:</span><span class=n>pointLineDistance</span><span class=p>(</span><span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=n>i</span><span class=p>],</span> <span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=n>first</span><span class=p>],</span> <span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=n>last</span><span class=p>])</span>

    <span class=kr>if</span> <span class=n>d</span> <span class=o>></span> <span class=n>dmax</span> <span class=kr>then</span>
      <span class=n>index</span> <span class=o>=</span> <span class=n>i</span>
      <span class=n>dmax</span> <span class=o>=</span> <span class=n>d</span>
    <span class=kr>end</span>
  <span class=kr>end</span>

  <span class=kr>if</span> <span class=n>dmax</span> <span class=o>>=</span> <span class=n>epsilon</span> <span class=kr>then</span>
    <span class=n>self</span><span class=p>.</span><span class=n>points</span><span class=p>[</span><span class=n>index</span><span class=p>].</span><span class=n>keep</span> <span class=o>=</span> <span class=kc>true</span>

    <span class=c1>-- Recursive call</span>
    <span class=n>self</span><span class=p>:</span><span class=n>douglasPeucker</span><span class=p>(</span><span class=n>first</span><span class=p>,</span> <span class=n>index</span><span class=p>,</span> <span class=n>epsilon</span><span class=p>)</span>
    <span class=n>self</span><span class=p>:</span><span class=n>douglasPeucker</span><span class=p>(</span><span class=n>index</span><span class=p>,</span> <span class=n>last</span><span class=p>,</span> <span class=n>epsilon</span><span class=p>)</span>
  <span class=kr>end</span>
<span class=kr>end</span>

<span class=kr>function</span> <span class=nc>Bezier</span><span class=p>:</span><span class=nf>pointLineDistance</span><span class=p>(</span><span class=n>p</span><span class=p>,</span> <span class=n>a</span><span class=p>,</span> <span class=n>b</span><span class=p>)</span>
  <span class=c1>-- calculates area of the triangle</span>
  <span class=kd>local</span> <span class=n>area</span> <span class=o>=</span> <span class=nb>math.abs</span><span class=p>(</span><span class=mf>0.5</span> <span class=o>*</span> <span class=p>(</span><span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span> <span class=o>+</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>a</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>a</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>p</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>b</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>*</span> <span class=n>p</span><span class=p>.</span><span class=n>y</span><span class=p>))</span>
  <span class=c1>-- calculates the length of the bottom edge</span>
  <span class=kd>local</span> <span class=n>dx</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>x</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>x</span>
  <span class=kd>local</span> <span class=n>dy</span> <span class=o>=</span> <span class=n>a</span><span class=p>.</span><span class=n>y</span> <span class=o>-</span> <span class=n>b</span><span class=p>.</span><span class=n>y</span>
  <span class=kd>local</span> <span class=n>bottom</span> <span class=o>=</span> <span class=nb>math.sqrt</span><span class=p>(</span><span class=n>dx</span><span class=o>*</span><span class=n>dx</span> <span class=o>+</span> <span class=n>dy</span><span class=o>*</span><span class=n>dy</span><span class=p>)</span>
  <span class=c1>-- the triangle's height is also the distance found</span>
  <span class=kr>return</span> <span class=n>area</span> <span class=o>/</span> <span class=n>bottom</span>
<span class=kr>end</span>
</code></pre></div><p>This now gives us 34 points. It spreads them out on the straighter parts, but packs them in on the sharp corners so they will appear as smooth as the un-reduced version. So visually this is exactly what I wanted, but at what cost?<p><img alt="Steps: auto, Epsilon: 0.1" src=../../images/better-bezier-class-gideros/stepsauto_epsilonpoint1.png><h3>Performance</h3><p>At first I expected these extra operations to slow everything down, but I figured it was worth it in certain cases. However, I was surprised to find that by far the slowest part of rendering the curve is actually having Gideros draw it as a series of connected lines. So while my <code>reduce()</code> function <em>is</em> expensive, because it reduces the number of points so much, the end result is less drawing, and so overall it's faster. Here are some benchmarks of the curve in the images above, running in the desktop player:<table><thead><tr><th>Parameters<th>#points<th>Creation<th>Drawing<th>Reduction<th>Total<tbody><tr><td>100 steps, no reduce<td>101<td>0.12ms<td>1.94ms<td>0.00ms<td>2.07ms<tr><td>Auto steps, no reduce<td>153<td>0.21ms<td>3.15ms<td>0.00ms<td>3.36ms<tr><td>Auto steps, .1 epsilon<td>34<td>0.21ms<td>0.67ms<td>0.82ms<td>1.70ms</table><h3>Source</h3><p>The full class and a test project is <a href=https://github.com/nshafer/Bezier>available at github</a>.<p><img alt="Screenshot of Bezier test program" src=../../images/better-bezier-class-gideros/Bezier_test_program.png><h3>Further</h3><p>If you're interested in a different approach altogether, take a look at Maxim Shemanarev's paper, <a href=http://antigrain.com/research/adaptive_bezier/>"Adaptive Subdivision of Bezier Curves."</a> It is a much more complicated algorithm, but he gets beautiful results.</div><section id=share-buttons><h3>Share this:</h3><ul><li><a class="btn btn-facebook" href="https://www.facebook.com/sharer/sharer.php?u=../../2013/05/implementing-better-bezier-class-in.html&t=Implementing a better Bezier class in Gideros" title="Share on Facebook" target=_blank> <i class="fa fa-facebook"></i> Facebook </a><li><a class="btn btn-twitter" href="https://twitter.com/intent/tweet?source=../../2013/05/implementing-better-bezier-class-in.html&text=Implementing a better Bezier class in Gideros" target=_blank title=Tweet> <i class="fa fa-twitter"></i> Twitter </a><li><a class="btn btn-reddit" href="http://www.reddit.com/submit?url=../../2013/05/implementing-better-bezier-class-in.html&title=Implementing a better Bezier class in Gideros" title="Submit to Reddit" target=_blank> <i class="fa fa-reddit"></i> Reddit </a><li><a class="btn btn-email" href="mailto:?subject=Implementing a better Bezier class in Gideros&body=Article+from+lchfkorea%0D%0A%0D%0A../../2013/05/implementing-better-bezier-class-in.html%0D%0A%0D%0AOptimizing a basic Bezier curve class for better performance by selectively reducing point counts while maintaining high quality, smooth curves." target=_blank title=Email> <i class="fa fa-envelope"></i> Email </a></ul></section></section><footer id=main-footer><section id=links><section><h3>Pages</h3><ul><li><a href=../../>Home</a><li><a href=../../archives.html>Archives</a><li><a href=../../pages/colophon.html>Colophon</a></ul></section><section><h3>Categories</h3><ul><li><a href=../../category/graphics.html>Graphics</a><li><a href=../../category/misc.html>misc</a><li><a href=../../category/mobile.html>Mobile</a><li><a href=../../category/web.html>Web</a></ul></section><section><h3>Tags</h3><ul class=tag-cloud><li class=tag-1><a href=../../tag/android.html>android</a><li class=tag-1><a href=../../tag/css.html>css</a><li class="tag-1 tag-2"><a href=../../tag/django.html>django</a><li class=tag-1><a href=../../tag/docker.html>docker</a><li class="tag-1 tag-2"><a href=../../tag/elixir.html>elixir</a><li class="tag-1 tag-2 tag-3"><a href=../../tag/gideros.html>gideros</a><li class=tag-1><a href=../../tag/gulp.html>gulp</a><li class=tag-1><a href=../../tag/ios.html>ios</a><li class="tag-1 tag-2 tag-3 tag-4"><a href=../../tag/lua.html>lua</a><li class="tag-1 tag-2"><a href=../../tag/math.html>math</a><li class=tag-1><a href=../../tag/pelican.html>pelican</a><li class="tag-1 tag-2"><a href=../../tag/phoenix.html>phoenix</a><li class=tag-1><a href=../../tag/plug.html>plug</a><li class="tag-1 tag-2"><a href=../../tag/postgres.html>postgres</a><li class=tag-1><a href=../../tag/pycharm.html>pycharm</a><li class=tag-1><a href=../../tag/responsive.html>responsive</a><li class=tag-1><a href=../../tag/sass.html>sass</a><li class=tag-1><a href=../../tag/sublime-text.html>sublime-text</a><li class=tag-1><a href=../../tag/web-design.html>web design</a></ul></section><address><h3>Nathan Shafer</h3> <ul><li><a href=https://www.github.com/nshafer>Github</a><li><a href=http://www.normal-tech.com>Normal Technologies LLC</a><li><a href=http://www.typeingames.com>Type-in Games</a></ul></address></section><section id=subfooter><section id=copyright><p>© 2025 Nathan Shafer<p id=license>All work is licensed under a <a href=http://creativecommons.org/licenses/by/4.0/ rel=license>Creative Commons Attribution 4.0 International License</a> unless otherwise specified.</section><a title="Subscribe to my feed" href=http://feeds.feedburner.com/Lotechnica id=subscribe-link rel=alternate type=application/rss+xml> <img alt src=//feedburner.google.com/fb/images/pub/feed-icon32x32.png style=border:0> </a></section></footer>